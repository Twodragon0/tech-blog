<!-- Sentry Error Tracking -->
<!-- 
  공식 Loader Script 사용 (권장)
  DSN: https://61fd23528aff138753e071de26c5b306@o4510686170710016.ingest.us.sentry.io/4510686177984512
  
  Free 티어 최적화 (월 5,000 이벤트 제한):
  - 프로덕션만 수집 (개발/프리뷰 환경 제외)
  - 동적 샘플링: 이벤트 수에 따라 자동 조정 (50%-100%)
  - 트레이스 샘플링: 5% (프로덕션)
  - 로그: warn, error만 전송 (info, debug 제외)
  - console.log는 전송하지 않음
  - 민감 정보 자동 필터링 (강화)
  - 중복 에러 그룹핑 최적화 (로컬 스토리지 기반)
  - 이벤트 크기 제한: 8KB (자동 축소)
  - 월간 이벤트 수 추적 및 경고
  
  설정 방법:
  1. Sentry.io 프로젝트 설정에서 Loader Script 복사
  2. 아래 스크립트 태그의 src URL 업데이트 (필요시)
  3. DSN은 Loader Script에 포함되어 있음
-->

<!-- Sentry Loader Script (페이지 상단에 위치) -->
<script
  src="https://js.sentry-cdn.com/61fd23528aff138753e071de26c5b306.min.js"
  crossorigin="anonymous"
></script>

<!-- Sentry 초기화 (Loader Script 로드 후 실행) -->
<script>
(function() {
  'use strict';
  
  // Sentry가 로드될 때까지 대기 (CSP 위반 시 로드되지 않을 수 있음)
  if (typeof Sentry === 'undefined') {
    // 개발 환경에서만 경고 (프로덕션에서는 조용히 실패)
    if (window.location.hostname === 'localhost' || window.location.hostname === '127.0.0.1') {
      console.warn('[Sentry] Loader script not loaded - CSP may be blocking it');
    }
    return;
  }

  // Sentry.onLoad()를 사용하여 초기화 (Loader Script 방식)
  Sentry.onLoad(function() {
    Sentry.init({
      // 환경 설정
      environment: window.location.hostname === 'tech.2twodragon.com' 
        ? 'production' 
        : window.location.hostname === 'localhost' || window.location.hostname === '127.0.0.1'
        ? 'development'
        : 'preview',
      
      // Tracing: 성능 모니터링 (Free 티어 최적화: 5% 샘플링)
      // Free 티어는 월 5,000 이벤트 제한이 있으므로 샘플링을 낮춤
      tracesSampleRate: window.location.hostname === 'tech.2twodragon.com' 
        ? 0.05  // 프로덕션: 5% (Free 티어 최적화)
        : 0.0,  // 개발/프리뷰: 0% (개발 환경은 트레이스 수집 안 함)
      
      // Session Replay: 세션 재생 (비용 최적화)
      replaysSessionSampleRate: 0.0, // 0% (비활성화 - 비용 절감)
      replaysOnErrorSampleRate: 0.0, // 0% (비활성화 - 비용 절감)
      
      // Logs: 구조화된 로깅 활성화 (SDK 9.41.0+)
      enableLogs: true,
      
      // Source Maps: 프로덕션에서는 비활성화 (CSP 위반 방지 및 보안)
      // 개발 환경에서만 source map 로드
      _experiments: {
        // Source map 로드 비활성화 (프로덕션)
        enableSourceMaps: window.location.hostname === 'localhost' || window.location.hostname === '127.0.0.1'
      },
      
      // 릴리스 정보 (선택사항)
      // release: 'tech-blog@1.0.0',
      
      // 에러 필터링 및 보안 - Free 티어 최적화
      beforeSend(event, hint) {
        // Free 티어 최적화: 개발 환경 에러는 전송하지 않음
        if (window.location.hostname !== 'tech.2twodragon.com') {
          return null; // 프로덕션만 에러 수집
        }
        
        // Unknown error 개선: 에러 메시지가 없거나 불충분한 경우 컨텍스트 추가
        if (!event.message || event.message === 'Unknown error' || event.message.trim() === '') {
          // hint에서 원본 에러 정보 추출
          const originalError = hint.originalException;
          if (originalError) {
            if (originalError.message) {
              event.message = originalError.message;
            } else if (originalError.toString && originalError.toString() !== '[object Object]') {
              event.message = originalError.toString();
            } else if (originalError.__sentry_context__) {
              event.message = originalError.__sentry_context__.message || 'Unknown error with context';
            } else {
              event.message = 'Unknown error - no error message available';
            }
            
            // 스택 트레이스가 있으면 추가
            if (originalError.stack && !event.exception) {
              event.exception = {
                values: [{
                  type: originalError.name || 'Error',
                  value: event.message,
                  stacktrace: {
                    frames: originalError.stack.split('\n').slice(0, 10).map((line, index) => ({
                      filename: line.match(/\((.+):\d+:\d+\)/) ? RegExp.$1 : 'unknown',
                      lineno: line.match(/:(\d+):\d+\)/) ? parseInt(RegExp.$1) : 0,
                      colno: line.match(/:\d+:(\d+)\)/) ? parseInt(RegExp.$1) : 0,
                      function: line.match(/at\s+(.+)\s+\(/) ? RegExp.$1 : 'unknown'
                    }))
                  }
                }]
              };
            }
          }
          
          // 추가 컨텍스트 정보
          if (!event.extra) {
            event.extra = {};
          }
          event.extra.errorContext = {
            url: window.location.href,
            userAgent: navigator.userAgent,
            timestamp: new Date().toISOString(),
            referrer: document.referrer || 'none'
          };
        }
        
        // 민감 정보 제거 및 보안 강화
        if (event.request) {
          // 쿠키 제거
          delete event.request.cookies;
          
          // URL에서 민감한 쿼리 파라미터 제거
          if (event.request.url) {
            try {
              const url = new URL(event.request.url);
              const sensitiveParams = [
                'token', 'key', 'password', 'secret', 'api_key', 'apikey',
                'access_token', 'refresh_token', 'auth', 'authorization',
                'credential', 'private_key', 'session', 'sessionid'
              ];
              sensitiveParams.forEach(param => {
                url.searchParams.delete(param);
              });
              event.request.url = url.toString();
            } catch (e) {
              // URL 파싱 실패 시 그대로 유지
            }
          }
        }
        
        // 스택 트레이스에서 민감 정보 제거
        if (event.exception && event.exception.values) {
          event.exception.values.forEach(exception => {
            if (exception.stacktrace && exception.stacktrace.frames) {
              exception.stacktrace.frames.forEach(frame => {
                // 파일 경로에서 민감 정보 제거
                if (frame.filename) {
                  frame.filename = frame.filename.replace(/\/home\/[^\/]+/g, '/home/***');
                  frame.filename = frame.filename.replace(/\/Users\/[^\/]+/g, '/Users/***');
                }
                // 코드 컨텍스트에서 민감 정보 제거 (강화)
                if (frame.vars) {
                  Object.keys(frame.vars).forEach(key => {
                    const lowerKey = key.toLowerCase();
                    const value = String(frame.vars[key] || '').toLowerCase();
                    
                    // 키 이름 기반 필터링
                    if (lowerKey.includes('password') || 
                        lowerKey.includes('token') || 
                        lowerKey.includes('secret') ||
                        lowerKey.includes('key') ||
                        lowerKey.includes('auth') ||
                        lowerKey.includes('credential') ||
                        lowerKey.includes('api_key') ||
                        lowerKey.includes('apikey') ||
                        lowerKey.includes('private') ||
                        lowerKey.includes('session')) {
                      frame.vars[key] = '***REDACTED***';
                    }
                    // 값 내용 기반 필터링 (추가 보안)
                    else if (value.includes('password') ||
                             value.includes('token') ||
                             value.includes('secret') ||
                             value.includes('api_key') ||
                             value.includes('bearer ') ||
                             value.match(/[a-zA-Z0-9]{32,}/)) { // 긴 문자열 (토큰 가능성)
                      frame.vars[key] = '***REDACTED***';
                    }
                  });
                }
                
                // 함수 인자에서 민감 정보 제거
                if (frame.args) {
                  frame.args = frame.args.map(arg => {
                    const argStr = String(arg || '');
                    if (argStr.length > 50 && 
                        (argStr.includes('token') || 
                         argStr.includes('password') || 
                         argStr.includes('secret') ||
                         argStr.match(/[a-zA-Z0-9]{32,}/))) {
                      return '***REDACTED***';
                    }
                    return arg;
                  });
                }
              });
            }
          });
        }
        
        // 특정 에러 무시 (정상적인 보안 에러 및 이미지 로드 실패)
        if (event.exception) {
          const error = hint.originalException;
          if (error && error.message) {
            const errorMessage = error.message.toLowerCase();
            // CSP 위반, 확장 프로그램 관련 에러는 무시
            // 이미지 로드 실패 (404, 한글 파일명 인코딩 문제 등)는 무시
            // Long task는 성능 경고이지 에러가 아니므로 무시 (성능 모니터링은 별도로 처리)
            if (errorMessage.includes('content security policy') ||
                errorMessage.includes('csp') ||
                errorMessage.includes('extension') ||
                errorMessage.includes('chrome-extension') ||
                errorMessage.includes('moz-extension') ||
                errorMessage.includes('failed to load') ||
                errorMessage.includes('load link') ||
                errorMessage.includes('long task detected') ||
                errorMessage.includes('layout shift detected') ||
                (errorMessage.includes('image') && (errorMessage.includes('404') || errorMessage.includes('not found')))) {
              return null; // 이벤트 무시
            }
          }
        }
        
        // Long task 및 성능 관련 에러 필터링 (커스텀 컨텍스트 기반)
        if (event.contexts && event.contexts.custom) {
          const customContext = event.contexts.custom;
          // Long task는 성능 경고이지 에러가 아님 (100-200ms는 허용 가능한 범위)
          if (customContext.type === 'performance' && 
              (customContext.duration !== undefined || customContext.metric === 'CLS')) {
            return null; // 성능 메트릭은 에러로 보고하지 않음
          }
        }
        
        // 에러 메시지에서 Long task 패턴 확인 (추가 안전장치)
        if (event.message) {
          const message = event.message.toLowerCase();
          if (message.includes('long task') || message.includes('layout shift')) {
            return null; // 성능 경고는 에러로 보고하지 않음
          }
        }
        
        // 이미지 로드 실패 에러 필터링 (request URL 기반)
        if (event.request && event.request.url) {
          const url = event.request.url.toLowerCase();
          // OG 이미지, 한글 파일명 포함 URL은 무시
          if (url.includes('_og.png') || 
              url.includes('og.png') || 
              url.includes('og.jpg') || 
              url.includes('og.webp') ||
              url.includes('favicon') ||
              url.includes('robots.txt') ||
              /[\uAC00-\uD7A3]/.test(event.request.url)) { // 한글 포함된 URL
            return null; // 이벤트 무시
          }
        }
        
        // Free 티어 최적화: 중복 에러 그룹핑 최적화
        // 동일한 에러가 너무 많이 발생하면 샘플링 (로컬 스토리지 기반)
        const errorKey = event.fingerprint ? event.fingerprint.join('-') : 
                        (event.message || event.exception?.values?.[0]?.value || 'unknown');
        const errorCountKey = 'sentry_error_count_' + errorKey.substring(0, 50);
        const errorTimestampKey = 'sentry_error_timestamp_' + errorKey.substring(0, 50);
        
        try {
          const errorCount = parseInt(localStorage.getItem(errorCountKey) || '0');
          const lastErrorTime = parseInt(localStorage.getItem(errorTimestampKey) || '0');
          const now = Date.now();
          const oneHour = 60 * 60 * 1000;
          
          // 1시간 이내에 동일한 에러가 10번 이상 발생하면 샘플링 (50%)
          if (errorCount > 10 && (now - lastErrorTime) < oneHour) {
            if (Math.random() > 0.5) {
              return null; // 50% 샘플링
            }
          }
          
          // 에러 카운트 업데이트 (1시간마다 리셋)
          if ((now - lastErrorTime) > oneHour) {
            localStorage.setItem(errorCountKey, '1');
          } else {
            localStorage.setItem(errorCountKey, (errorCount + 1).toString());
          }
          localStorage.setItem(errorTimestampKey, now.toString());
        } catch (e) {
          // localStorage 접근 실패 시 무시 (프라이빗 모드 등)
        }
        
        // Free 티어 최적화: 이벤트 크기 제한 강화 (전체 이벤트 크기 제한)
        const eventSize = JSON.stringify(event).length;
        const maxEventSize = 8000; // 8KB 제한 (Free 티어 최적화)
        
        if (eventSize > maxEventSize) {
          // 이벤트 크기 축소
          if (event.extra) {
            const extraSize = JSON.stringify(event.extra).length;
            if (extraSize > 2000) {
              event.extra = { 
                message: 'Extra data truncated for Free tier optimization',
                originalSize: extraSize,
                truncated: true
              };
            }
          }
          
          // breadcrumbs 제한
          if (event.breadcrumbs && event.breadcrumbs.length > 10) {
            event.breadcrumbs = event.breadcrumbs.slice(-10); // 최근 10개만 유지
          }
          
          // contexts 제한
          if (event.contexts) {
            Object.keys(event.contexts).forEach(key => {
              const contextSize = JSON.stringify(event.contexts[key]).length;
              if (contextSize > 1000) {
                event.contexts[key] = { message: 'Context data truncated' };
              }
            });
          }
          
          // 최종 크기 확인 - 여전히 크면 추가 축소
          const finalSize = JSON.stringify(event).length;
          if (finalSize > maxEventSize) {
            // 스택 트레이스 프레임 제한
            if (event.exception?.values) {
              event.exception.values.forEach(exception => {
                if (exception.stacktrace?.frames && exception.stacktrace.frames.length > 20) {
                  exception.stacktrace.frames = exception.stacktrace.frames.slice(-20); // 최근 20개만
                }
              });
            }
          }
        }
        
        return event;
      },
      
      // 로그 필터링 및 보안 (beforeSendLog) - Free 티어 최적화
      beforeSendLog(log, hint) {
        // Free 티어 최적화: 개발 환경 로그는 전송하지 않음
        if (window.location.hostname !== 'tech.2twodragon.com') {
          return null; // 프로덕션만 로그 수집
        }
        
        // Free 티어 최적화: info, debug 레벨은 전송하지 않음 (warn, error만)
        // 단, 초기화 확인 로그는 예외 (환경 정보 포함)
        const isInitializationLog = log.message && 
          (log.message.includes('Sentry initialized') || 
           log.message.includes('Logs enabled'));
        
        if ((log.level === 'info' || log.level === 'debug' || log.level === 'trace') && !isInitializationLog) {
          return null; // info, debug, trace는 제외 (Free 티어 최적화)
        }
        
        // 초기화 로그는 info를 warn으로 변환 (beforeSendLog에서 필터링 방지)
        if (isInitializationLog && log.level === 'info') {
          log.level = 'warn';
        }
        
        // 민감 정보 제거
        if (log.message) {
          // 민감한 정보가 포함된 로그 필터링
          const sensitivePatterns = [
            /password/i,
            /token/i,
            /secret/i,
            /api[_-]?key/i,
            /apikey/i,
            /authorization/i,
            /bearer/i,
            /credential/i,
            /private[_-]?key/i
          ];
          
          if (sensitivePatterns.some(pattern => pattern.test(log.message))) {
            return null; // 민감한 로그는 전송하지 않음
          }
        }
        
        // 중복 로그 필터링: 동일한 메시지가 너무 많으면 제한
        // (실제로는 Sentry가 자동으로 그룹핑하지만, 추가 필터링)
        if (log.message && log.message.length > 1000) {
          // 너무 긴 로그는 잘라서 전송 (비용 절감)
          log.message = log.message.substring(0, 1000) + '... [truncated]';
        }
        
        // 동일한 로그가 너무 많이 발생하면 샘플링 (로컬 스토리지 기반)
        const logKey = log.message ? log.message.substring(0, 100) : 'unknown';
        const logCountKey = 'sentry_log_count_' + logKey.replace(/[^a-zA-Z0-9]/g, '_').substring(0, 50);
        const logTimestampKey = 'sentry_log_timestamp_' + logKey.replace(/[^a-zA-Z0-9]/g, '_').substring(0, 50);
        
        try {
          const logCount = parseInt(localStorage.getItem(logCountKey) || '0');
          const lastLogTime = parseInt(localStorage.getItem(logTimestampKey) || '0');
          const now = Date.now();
          const oneHour = 60 * 60 * 1000;
          
          // 1시간 이내에 동일한 로그가 20번 이상 발생하면 샘플링 (30%)
          if (logCount > 20 && (now - lastLogTime) < oneHour) {
            if (Math.random() > 0.3) {
              return null; // 70% 샘플링
            }
          }
          
          // 로그 카운트 업데이트 (1시간마다 리셋)
          if ((now - lastLogTime) > oneHour) {
            localStorage.setItem(logCountKey, '1');
          } else {
            localStorage.setItem(logCountKey, (logCount + 1).toString());
          }
          localStorage.setItem(logTimestampKey, now.toString());
        } catch (e) {
          // localStorage 접근 실패 시 무시
        }
        
        return log;
      },
      
      // 샘플링 함수 (에러 수집률) - 동적 샘플링 구현
      // Free 티어 최적화: 프로덕션만 수집, 개발 환경은 제외
      // 월 5,000 이벤트 제한을 고려한 동적 샘플링
      sampleRate: (function() {
        // 개발/프리뷰 환경은 수집하지 않음
        if (window.location.hostname !== 'tech.2twodragon.com') {
          return 0.0;
        }
        
        // 동적 샘플링: 월간 이벤트 수에 따라 자동 조정
        try {
          const monthlyEventsKey = 'sentry_monthly_events';
          const monthlyTimestampKey = 'sentry_monthly_timestamp';
          const now = Date.now();
          const oneMonth = 30 * 24 * 60 * 60 * 1000;
          
          let monthlyEvents = parseInt(localStorage.getItem(monthlyEventsKey) || '0');
          let monthlyTimestamp = parseInt(localStorage.getItem(monthlyTimestampKey) || '0');
          
          // 월이 지나면 리셋
          if ((now - monthlyTimestamp) > oneMonth || monthlyTimestamp === 0) {
            monthlyEvents = 0;
            monthlyTimestamp = now;
            localStorage.setItem(monthlyEventsKey, '0');
            localStorage.setItem(monthlyTimestampKey, now.toString());
          }
          
          const freeTierLimit = 5000; // Free 티어 제한
          const daysInMonth = 30;
          const dailyLimit = freeTierLimit / daysInMonth; // 약 166개/일
          const currentDay = Math.floor((now - monthlyTimestamp) / (24 * 60 * 60 * 1000)) + 1;
          const expectedDailyAverage = monthlyEvents / currentDay;
          
          // 80% 이상 사용 시 샘플링 50%
          if (monthlyEvents > freeTierLimit * 0.8) {
            return 0.5;
          }
          // 60% 이상 사용 시 샘플링 75%
          else if (monthlyEvents > freeTierLimit * 0.6) {
            return 0.75;
          }
          // 일일 평균이 제한의 90% 이상이면 샘플링 90%
          else if (expectedDailyAverage > dailyLimit * 0.9) {
            return 0.9;
          }
          // 일일 평균이 제한의 70% 이상이면 샘플링 95%
          else if (expectedDailyAverage > dailyLimit * 0.7) {
            return 0.95;
          }
          
          // 정상 범위: 100% 수집
          return 1.0;
        } catch (e) {
          // localStorage 접근 실패 시 기본값 100% (프라이빗 모드 등)
          return 1.0;
        }
      })(),
      
      // 통합 설정
      // 참고: Loader Script를 사용할 때는 consoleLoggingIntegration을 사용할 수 없음
      // 대신 beforeSendLog에서 필터링하여 warn, error만 전송 (아래 beforeSendLog 참조)
      integrations: [
        // BrowserTracing은 Loader Script에서 자동 설정됨
        // Console 로깅은 beforeSendLog에서 처리 (Loader Script 제한으로 인해 통합 사용 불가)
      ],
    });

    // 사용자 컨텍스트 설정 (선택사항)
    // Sentry.setUser({
    //   id: 'anonymous',
    //   username: 'visitor'
    // });

    // 개발 환경에서만 로그
    if (window.location.hostname === 'localhost' || window.location.hostname === '127.0.0.1') {
      console.log('[Sentry] Initialized successfully');
    }
    
    // 전역 에러 핸들러 설정 (Unknown error 방지)
    window.addEventListener('error', function(event) {
      // 이미 Sentry가 처리한 에러는 건너뛰기
      if (event.error && event.error.__sentry_handled__) {
        return;
      }
      
      // 에러 컨텍스트 수집
      const errorContext = {
        message: event.message || 'Unknown error',
        filename: event.filename || 'unknown',
        lineno: event.lineno || 0,
        colno: event.colno || 0,
        error: event.error ? {
          name: event.error.name,
          message: event.error.message,
          stack: event.error.stack
        } : null,
        url: window.location.href,
        userAgent: navigator.userAgent,
        timestamp: new Date().toISOString()
      };
      
      // Sentry에 에러 전송 (Unknown error를 방지하기 위해 상세 정보 포함)
      if (typeof Sentry !== 'undefined' && Sentry.captureException) {
        const error = event.error || new Error(event.message || 'Unknown error');
        error.__sentry_context__ = errorContext;
        
        // 월간 이벤트 수 추적 (Free 티어 제한 모니터링)
        try {
          const monthlyEventsKey = 'sentry_monthly_events';
          const monthlyTimestampKey = 'sentry_monthly_timestamp';
          const now = Date.now();
          const oneMonth = 30 * 24 * 60 * 60 * 1000;
          
          let monthlyEvents = parseInt(localStorage.getItem(monthlyEventsKey) || '0');
          let monthlyTimestamp = parseInt(localStorage.getItem(monthlyTimestampKey) || '0');
          
          // 월이 지나면 리셋
          if ((now - monthlyTimestamp) > oneMonth || monthlyTimestamp === 0) {
            monthlyEvents = 0;
            monthlyTimestamp = now;
            localStorage.setItem(monthlyEventsKey, '0');
            localStorage.setItem(monthlyTimestampKey, now.toString());
          }
          
          // 이벤트 수 증가
          monthlyEvents++;
          localStorage.setItem(monthlyEventsKey, monthlyEvents.toString());
          
          // 80% 이상 사용 시 경고 (개발 환경에서만)
          if (monthlyEvents > 4000 && (window.location.hostname === 'localhost' || window.location.hostname === '127.0.0.1')) {
            console.warn('[Sentry] Monthly event limit warning:', monthlyEvents, '/ 5000');
          }
        } catch (e) {
          // localStorage 접근 실패 시 무시
        }
        
        Sentry.captureException(error, {
          tags: {
            errorType: 'global_error',
            handled: false
          },
          extra: errorContext,
          contexts: {
            browser: {
              name: navigator.userAgent,
              version: navigator.appVersion
            }
          }
        });
      }
    }, true); // capture phase에서도 처리
    
    // Promise rejection 핸들러 (Unhandled Promise Rejection 방지)
    window.addEventListener('unhandledrejection', function(event) {
      // 이미 Sentry가 처리한 에러는 건너뛰기
      if (event.reason && event.reason.__sentry_handled__) {
        return;
      }
      
      // 에러 컨텍스트 수집
      const errorContext = {
        message: event.reason ? (event.reason.message || String(event.reason)) : 'Unhandled Promise Rejection',
        type: event.reason ? event.reason.constructor.name : 'Unknown',
        url: window.location.href,
        userAgent: navigator.userAgent,
        timestamp: new Date().toISOString()
      };
      
      // Sentry에 에러 전송
      if (typeof Sentry !== 'undefined' && Sentry.captureException) {
        const error = event.reason instanceof Error 
          ? event.reason 
          : new Error(String(event.reason || 'Unhandled Promise Rejection'));
        
        error.__sentry_context__ = errorContext;
        
        // 월간 이벤트 수 추적 (Free 티어 제한 모니터링)
        try {
          const monthlyEventsKey = 'sentry_monthly_events';
          const monthlyTimestampKey = 'sentry_monthly_timestamp';
          const now = Date.now();
          const oneMonth = 30 * 24 * 60 * 60 * 1000;
          
          let monthlyEvents = parseInt(localStorage.getItem(monthlyEventsKey) || '0');
          let monthlyTimestamp = parseInt(localStorage.getItem(monthlyTimestampKey) || '0');
          
          // 월이 지나면 리셋
          if ((now - monthlyTimestamp) > oneMonth || monthlyTimestamp === 0) {
            monthlyEvents = 0;
            monthlyTimestamp = now;
            localStorage.setItem(monthlyEventsKey, '0');
            localStorage.setItem(monthlyTimestampKey, now.toString());
          }
          
          // 이벤트 수 증가
          monthlyEvents++;
          localStorage.setItem(monthlyEventsKey, monthlyEvents.toString());
        } catch (e) {
          // localStorage 접근 실패 시 무시
        }
        
        Sentry.captureException(error, {
          tags: {
            errorType: 'unhandled_promise_rejection',
            handled: false
          },
          extra: errorContext,
          contexts: {
            browser: {
              name: navigator.userAgent,
              version: navigator.appVersion
            }
          }
        });
      }
    });
    
    // Sentry Logs 검증 (프로덕션에서만 - Free 티어 최적화)
    if (window.location.hostname === 'tech.2twodragon.com') {
      // 초기화 확인 로그 전송 (한 번만)
      if (Sentry.logger && typeof Sentry.logger.info === 'function') {
        // info 레벨은 beforeSendLog에서 필터링되므로 warn으로 전송
        Sentry.logger.warn('Sentry initialized with Logs enabled', {
          environment: 'production',
          timestamp: new Date().toISOString(),
          sdk: 'browser',
          version: Sentry.SDK_VERSION || 'unknown'
        });
      }
    }
  });
})();
</script>

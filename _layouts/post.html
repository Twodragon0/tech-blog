---
layout: default
---
<div class="reading-progress" id="reading-progress"></div>

<article class="post-article" itemscope itemtype="http://schema.org/BlogPosting">
  <header class="post-header">
    {% if page.image %}
    <div class="post-image">
      {% assign image_path = page.image | relative_url %}
      {% comment %} í•œê¸€ íŒŒì¼ëª…ì´ í¬í•¨ëœ ê²½ìš° URL ì¸ì½”ë”© ë³´ì¥ {% endcomment %}
      <img src="{{ image_path }}" alt="{{ page.title | escape }}" class="clickable-image" data-full-src="{{ image_path }}" data-original-src="{{ page.image }}" loading="eager" decoding="async" fetchpriority="high" style="width:100%; height:auto; border-radius:8px; margin-bottom: 20px; cursor: zoom-in;">
    </div>
    {% endif %}

    {% if page.category %}
    <div class="post-category">
      <a href="{{ '/categories/' | relative_url }}#{{ page.category | downcase }}" class="category-badge {{ page.category | downcase }}">
        {{ page.category }}
      </a>
    </div>
    {% elsif page.categories.first %}
    <div class="post-category">
      <a href="{{ '/categories/' | relative_url }}#{{ page.categories.first | downcase | replace: ' ', '-' }}" class="category-badge {{ page.categories.first | downcase | replace: ' ', '-' }}">
        {{ page.categories.first }}
      </a>
    </div>
    {% endif %}

    <h1 class="post-title" itemprop="name headline">{{ page.title | escape }}</h1>

    <div class="post-meta">
      <span class="meta-item">
        <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
          <rect x="3" y="4" width="18" height="18" rx="2" ry="2"/>
          <line x1="16" y1="2" x2="16" y2="6"/>
          <line x1="8" y1="2" x2="8" y2="6"/>
          <line x1="3" y1="10" x2="21" y2="10"/>
        </svg>
        <time class="dt-published" datetime="{{ page.date | date_to_xmlschema }}" itemprop="datePublished">
          {{ page.date | date: "%Y. %m. %d" }}
        </time>
      </span>

      <span class="meta-item">
        <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
          <circle cx="12" cy="12" r="10"/>
          <polyline points="12 6 12 12 16 14"/>
        </svg>
        <span id="reading-time"></span>
      </span>

      <span class="meta-item" itemprop="author" itemscope itemtype="http://schema.org/Person">
        <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
          <path d="M20 21v-2a4 4 0 0 0-4-4H8a4 4 0 0 0-4 4v2"/>
          <circle cx="12" cy="7" r="4"/>
        </svg>
        <span itemprop="name">{{ site.author.name }}</span>
      </span>
    </div>

    {% if page.tags.size > 0 %}
    <div class="post-tags">
      {% for tag in page.tags %}
      <a href="{{ '/tags/' | relative_url }}#{{ tag | to_string | slugify }}" class="tag">{{ tag }}</a>
      {% endfor %}
    </div>
    {% endif %}

    <!-- Language Selector & Translate Button -->
    <div class="language-tools">
      <div class="language-selector">
        <button class="lang-btn active" data-lang="ko" title="í•œêµ­ì–´">
          <span class="lang-flag">ğŸ‡°ğŸ‡·</span>
          <span class="lang-name">í•œêµ­ì–´</span>
        </button>
        <button class="lang-btn" data-lang="en" title="English">
          <span class="lang-flag">ğŸ‡ºğŸ‡¸</span>
          <span class="lang-name">English</span>
        </button>
        <button class="lang-btn" data-lang="ja" title="æ—¥æœ¬èª">
          <span class="lang-flag">ğŸ‡¯ğŸ‡µ</span>
          <span class="lang-name">æ—¥æœ¬èª</span>
        </button>
        <button class="lang-btn" data-lang="zh" title="ä¸­æ–‡">
          <span class="lang-flag">ğŸ‡¨ğŸ‡³</span>
          <span class="lang-name">ä¸­æ–‡</span>
        </button>
        <a href="#" id="google-translate-link" class="translate-external" title="Google ë²ˆì—­ìœ¼ë¡œ ì—´ê¸°" target="_blank" rel="noopener">
          <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
            <path d="M18 13v6a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h6"/>
            <polyline points="15 3 21 3 21 9"/>
            <line x1="10" y1="14" x2="21" y2="3"/>
          </svg>
          <span>Google ë²ˆì—­</span>
        </a>
      </div>
      <div class="translate-status" id="translate-status"></div>
    </div>
  </header>

  {% if page.toc %}
  {% include toc.html content=content %}
  {% endif %}

  <div class="post-content" itemprop="articleBody">
    {{ content }}
  </div>

  <footer class="post-footer">
    {% if page.original_url %}
    <a href="{{ page.original_url }}" target="_blank" rel="noopener noreferrer" class="original-link">
      <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
        <path d="M18 13v6a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h6"/>
        <polyline points="15 3 21 3 21 9"/>
        <line x1="10" y1="14" x2="21" y2="3"/>
      </svg>
      ì›ë³¸ í¬ìŠ¤íŠ¸ ë³´ê¸°
    </a>
    {% endif %}

    {% include share-buttons.html %}
  </footer>

  {% assign posts = site.posts | where_exp: "post", "post.url != page.url" %}
  {% if page.category %}
    {% assign related = posts | where: "category", page.category | limit: 4 %}
  {% elsif page.categories.first %}
    {% assign cat = page.categories.first %}
    {% assign related = posts | where_exp: "post", "post.categories contains cat" | limit: 4 %}
  {% else %}
    {% assign related = posts | limit: 4 %}
  {% endif %}

  {% if related.size > 0 %}
  <section class="related-posts">
    <h3>Related Posts</h3>
    <div class="related-grid">
      {% for post in related limit: 4 %}
      <a href="{{ post.url | relative_url }}" class="related-item card">
        <h4>{{ post.title | escape }}</h4>
        <span class="related-date">{{ post.date | date: "%Y. %m. %d" }}</span>
      </a>
      {% endfor %}
    </div>
  </section>
  {% endif %}

  {% include giscus.html %}
</article>

<script>
// Reading time calculation
document.addEventListener('DOMContentLoaded', function() {
  const content = document.querySelector('.post-content');
  if (content) {
    const text = content.textContent || content.innerText;
    const wordCount = text.trim().split(/\s+/).length;
    const readingTime = Math.ceil(wordCount / 200);
    document.getElementById('reading-time').textContent = readingTime + ' min read';
  }

  // Enhance external links in post content
  enhanceExternalLinks();
});

// Function to enhance external links with icons and attributes
function enhanceExternalLinks() {
  const postContent = document.querySelector('.post-content');
  if (!postContent) return;

  const links = postContent.querySelectorAll('a[href]');
  const currentHost = window.location.hostname;
  const currentProtocol = window.location.protocol;

  links.forEach(link => {
    const href = link.getAttribute('href');
    if (!href) return;

    // Skip if already processed or is a special link
    if (link.classList.contains('external-link-processed') || 
        href.startsWith('#') || 
        href.startsWith('mailto:') || 
        href.startsWith('tel:')) {
      return;
    }

    // Check if it's an external link
    const isExternal = (href.startsWith('http://') || href.startsWith('https://')) &&
                       !href.includes(currentHost) &&
                       !link.hasAttribute('target');

    // Check if it's an internal link that should open in new tab
    const shouldOpenNewTab = link.hasAttribute('target') && 
                             link.getAttribute('target') === '_blank';

    if (isExternal || shouldOpenNewTab) {
      // Add external link attributes for security
      if (!link.hasAttribute('target')) {
        link.setAttribute('target', '_blank');
      }
      if (!link.hasAttribute('rel')) {
        link.setAttribute('rel', 'noopener noreferrer');
      }

      // Add aria-label for accessibility
      const linkText = link.textContent.trim();
      if (!link.hasAttribute('aria-label')) {
        link.setAttribute('aria-label', `${linkText} (ìƒˆ ì°½ì—ì„œ ì—´ë¦¼)`);
      }

      // Add class for styling
      link.classList.add('external-link', 'external-link-processed');

      // Add title attribute if not present
      if (!link.hasAttribute('title')) {
        link.setAttribute('title', 'ìƒˆ ì°½ì—ì„œ ì—´ë¦¼');
      }
    }
  });
}

// Reading progress bar
window.addEventListener('scroll', function() {
  const article = document.querySelector('.post-article');
  const progressBar = document.getElementById('reading-progress');
  if (article && progressBar) {
    const articleTop = article.offsetTop;
    const articleHeight = article.offsetHeight;
    const windowHeight = window.innerHeight;
    const scrollY = window.scrollY;
    const progress = Math.min(Math.max((scrollY - articleTop + windowHeight * 0.3) / articleHeight * 100, 0), 100);
    progressBar.style.width = progress + '%';
  }
});

// Giscus loading state management
document.addEventListener('DOMContentLoaded', function() {
  const giscusContainer = document.getElementById('giscus-container');
  const giscusLoading = document.getElementById('giscus-loading');
  
  if (giscusContainer && giscusLoading) {
    // Giscusê°€ ë¡œë“œë˜ë©´ ë¡œë”© ì¸ë””ì¼€ì´í„° ìˆ¨ê¸°ê¸°
    const observer = new MutationObserver(function(mutations) {
      const giscusFrame = giscusContainer.querySelector('iframe');
      if (giscusFrame && giscusFrame.contentDocument) {
        giscusLoading.classList.add('hidden');
        observer.disconnect();
      }
    });

    observer.observe(giscusContainer, {
      childList: true,
      subtree: true
    });

    // ìµœëŒ€ ëŒ€ê¸° ì‹œê°„ ì„¤ì • (10ì´ˆ í›„ ìë™ìœ¼ë¡œ ë¡œë”© ì¸ë””ì¼€ì´í„° ìˆ¨ê¸°ê¸°)
    setTimeout(function() {
      if (!giscusLoading.classList.contains('hidden')) {
        giscusLoading.classList.add('hidden');
      }
    }, 10000);

    // Giscus ìŠ¤í¬ë¦½íŠ¸ ë¡œë“œ í™•ì¸
    const giscusScript = document.querySelector('script[src*="giscus.app"]');
    if (giscusScript) {
      giscusScript.addEventListener('load', function() {
        // ìŠ¤í¬ë¦½íŠ¸ ë¡œë“œ í›„ ì§§ì€ ì§€ì—°ì„ ë‘ê³  í™•ì¸
        setTimeout(function() {
          const giscusFrame = giscusContainer.querySelector('iframe');
          if (giscusFrame) {
            giscusLoading.classList.add('hidden');
          }
        }, 2000);
      });
    }
  }
});

// Translation functionality using Google Translate
(function() {
  const langButtons = document.querySelectorAll('.lang-btn');
  const translateStatus = document.getElementById('translate-status');
  const postContent = document.querySelector('.post-content');
  const postTitle = document.querySelector('.post-title');
  const googleTranslateLink = document.getElementById('google-translate-link');

  let originalContent = null;
  let originalTitle = null;
  let currentLang = 'ko';
  let translationCache = {};

  // Set Google Translate link
  if (googleTranslateLink) {
    googleTranslateLink.href = `https://translate.google.com/translate?sl=ko&tl=en&u=${encodeURIComponent(window.location.href)}`;
  }

  // Save original content
  if (postContent) {
    originalContent = postContent.innerHTML;
  }
  if (postTitle) {
    originalTitle = postTitle.textContent;
  }

  // Language button click handler
  langButtons.forEach(btn => {
    btn.addEventListener('click', async function() {
      const targetLang = this.dataset.lang;

      if (targetLang === currentLang) return;

      // Update active button
      langButtons.forEach(b => b.classList.remove('active'));
      this.classList.add('active');

      // Show loading status
      showStatus('ë²ˆì—­ ì¤‘...', 'loading');

      try {
        if (targetLang === 'ko') {
          // Restore original Korean content
          if (originalContent) postContent.innerHTML = originalContent;
          if (originalTitle) postTitle.textContent = originalTitle;
          currentLang = 'ko';
          showStatus('ì›ë³¸ìœ¼ë¡œ ë³µì›ë˜ì—ˆìŠµë‹ˆë‹¤', 'success');
        } else {
          // Translate to target language
          await translatePage(targetLang);
          currentLang = targetLang;
          showStatus(getLanguageName(targetLang) + 'ë¡œ ë²ˆì—­ë˜ì—ˆìŠµë‹ˆë‹¤', 'success');
        }
      } catch (error) {
        console.error('Translation error:', error);
        showStatus('ë²ˆì—­ ì‹¤íŒ¨. ë‹¤ì‹œ ì‹œë„í•´ì£¼ì„¸ìš”.', 'error');
      }
    });
  });

  async function translatePage(targetLang) {
    // Check cache first
    const cacheKey = targetLang;
    if (translationCache[cacheKey]) {
      if (translationCache[cacheKey].content) {
        postContent.innerHTML = translationCache[cacheKey].content;
      }
      if (translationCache[cacheKey].title) {
        postTitle.textContent = translationCache[cacheKey].title;
      }
      return;
    }

    // Use Google Translate widget approach (free, no API key needed)
    const translateUrl = `https://translate.google.com/translate?sl=ko&tl=${targetLang}&u=${encodeURIComponent(window.location.href)}`;

    // For inline translation, we'll use a different approach
    // Create a temporary iframe or use the LibreTranslate API

    // Alternative: Use browser's built-in translation hint
    // or redirect to Google Translate

    // Simple approach: Open Google Translate in new tab with option
    const useRedirect = false; // Set to true to redirect to Google Translate

    if (useRedirect) {
      window.open(translateUrl, '_blank');
      return;
    }

    // Inline translation using free API (MyMemory Translation API)
    await translateInline(targetLang);
  }

  async function translateInline(targetLang) {
    // Get text content to translate
    const textElements = postContent.querySelectorAll('p, h1, h2, h3, h4, h5, h6, li, td, th, blockquote, .summary-value, .summary-list li');

    const langMap = {
      'en': 'en-US',
      'ja': 'ja-JP',
      'zh': 'zh-CN'
    };

    const targetLangCode = langMap[targetLang] || targetLang;

    // Translate title
    if (postTitle && originalTitle) {
      const translatedTitle = await translateText(originalTitle, 'ko', targetLangCode);
      if (translatedTitle) {
        postTitle.textContent = translatedTitle;
      }
    }

    // Batch translate content
    const textsToTranslate = [];
    const elementsMap = [];

    textElements.forEach((el, index) => {
      const text = el.textContent.trim();
      if (text && text.length > 0 && text.length < 500) {
        textsToTranslate.push(text);
        elementsMap.push({ element: el, index: textsToTranslate.length - 1 });
      }
    });

    // Translate in batches
    const batchSize = 10;
    for (let i = 0; i < textsToTranslate.length; i += batchSize) {
      const batch = textsToTranslate.slice(i, i + batchSize);
      const translations = await Promise.all(
        batch.map(text => translateText(text, 'ko', targetLangCode))
      );

      translations.forEach((translated, j) => {
        const mapIndex = i + j;
        const item = elementsMap.find(m => m.index === mapIndex);
        if (item && translated) {
          // Preserve HTML structure, only replace text
          if (item.element.children.length === 0) {
            item.element.textContent = translated;
          }
        }
      });

      // Update progress
      const progress = Math.min(100, Math.round(((i + batchSize) / textsToTranslate.length) * 100));
      showStatus(`ë²ˆì—­ ì¤‘... ${progress}%`, 'loading');
    }

    // Cache the translation
    translationCache[targetLang] = {
      content: postContent.innerHTML,
      title: postTitle ? postTitle.textContent : null
    };
  }

  async function translateText(text, sourceLang, targetLang) {
    try {
      // Using MyMemory Translation API (free, 1000 words/day limit)
      const response = await fetch(
        `https://api.mymemory.translated.net/get?q=${encodeURIComponent(text)}&langpair=${sourceLang}|${targetLang}`
      );

      if (!response.ok) throw new Error('Translation API error');

      const data = await response.json();

      if (data.responseStatus === 200 && data.responseData) {
        return data.responseData.translatedText;
      }

      return null;
    } catch (error) {
      console.warn('Translation failed for:', text.substring(0, 50));
      return null;
    }
  }

  function showStatus(message, type) {
    if (!translateStatus) return;

    translateStatus.textContent = message;
    translateStatus.className = 'translate-status ' + type;

    if (type === 'success' || type === 'error') {
      setTimeout(() => {
        translateStatus.textContent = '';
        translateStatus.className = 'translate-status';
      }, 3000);
    }
  }

  function getLanguageName(lang) {
    const names = {
      'ko': 'í•œêµ­ì–´',
      'en': 'English',
      'ja': 'æ—¥æœ¬èª',
      'zh': 'ä¸­æ–‡'
    };
    return names[lang] || lang;
  }
})();

// Image Lightbox functionality
(function() {
  // Create lightbox elements
  const lightbox = document.createElement('div');
  lightbox.id = 'image-lightbox';
  lightbox.className = 'image-lightbox';
  lightbox.innerHTML = `
    <div class="lightbox-backdrop"></div>
    <div class="lightbox-content">
      <button class="lightbox-close" aria-label="ë‹«ê¸°">
        <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
          <line x1="18" y1="6" x2="6" y2="18"/>
          <line x1="6" y1="6" x2="18" y2="18"/>
        </svg>
      </button>
      <img class="lightbox-image" src="" alt="">
      <div class="lightbox-caption"></div>
      <div class="lightbox-controls">
        <button class="lightbox-zoom-in" aria-label="í™•ëŒ€">
          <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
            <circle cx="11" cy="11" r="8"/>
            <line x1="21" y1="21" x2="16.65" y2="16.65"/>
            <line x1="11" y1="8" x2="11" y2="14"/>
            <line x1="8" y1="11" x2="14" y2="11"/>
          </svg>
        </button>
        <button class="lightbox-zoom-out" aria-label="ì¶•ì†Œ">
          <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
            <circle cx="11" cy="11" r="8"/>
            <line x1="21" y1="21" x2="16.65" y2="16.65"/>
            <line x1="8" y1="11" x2="14" y2="11"/>
          </svg>
        </button>
        <button class="lightbox-reset" aria-label="ì›ë³¸ í¬ê¸°">
          <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
            <polyline points="15 3 21 3 21 9"/>
            <polyline points="9 21 3 21 3 15"/>
            <line x1="21" y1="3" x2="14" y2="10"/>
            <line x1="3" y1="21" x2="10" y2="14"/>
          </svg>
        </button>
      </div>
    </div>
  `;
  document.body.appendChild(lightbox);

  const lightboxImage = lightbox.querySelector('.lightbox-image');
  const lightboxCaption = lightbox.querySelector('.lightbox-caption');
  const lightboxClose = lightbox.querySelector('.lightbox-close');
  const lightboxBackdrop = lightbox.querySelector('.lightbox-backdrop');
  const zoomInBtn = lightbox.querySelector('.lightbox-zoom-in');
  const zoomOutBtn = lightbox.querySelector('.lightbox-zoom-out');
  const resetBtn = lightbox.querySelector('.lightbox-reset');

  let currentScale = 1;
  const scaleStep = 0.25;
  const maxScale = 3;
  const minScale = 0.5;

  // Open lightbox on image click
  function openLightbox(img) {
    const src = img.dataset.fullSrc || img.src;
    const alt = img.alt || '';

    if (!src) {
      console.error('Image source is missing');
      return;
    }

    // Reset scale and show loading state
    currentScale = 1;
    lightboxImage.style.transform = `scale(${currentScale})`;
    lightboxImage.style.opacity = '0';
    lightboxImage.style.display = 'block';
    lightboxImage.style.visibility = 'visible';
    
    // Reset caption style
    lightboxCaption.style.color = '#ffffff';
    lightboxCaption.textContent = alt;

    // Show lightbox immediately
    lightbox.classList.add('active');
    document.body.style.overflow = 'hidden';

    // Handle image load
    const handleImageLoad = () => {
      lightboxImage.style.opacity = '1';
      lightboxImage.style.transition = 'opacity 0.3s ease';
    };

    const handleImageError = () => {
      console.error('Failed to load image:', src);
      lightboxImage.style.opacity = '0.5';
      lightboxCaption.textContent = alt ? `${alt} (ì´ë¯¸ì§€ë¥¼ ë¶ˆëŸ¬ì˜¬ ìˆ˜ ì—†ìŠµë‹ˆë‹¤)` : 'ì´ë¯¸ì§€ë¥¼ ë¶ˆëŸ¬ì˜¬ ìˆ˜ ì—†ìŠµë‹ˆë‹¤';
      lightboxCaption.style.color = '#ff6b6b';
    };

    // Remove previous event listeners
    const newImageLoadHandler = handleImageLoad;
    const newImageErrorHandler = handleImageError;
    
    // Remove old listeners
    lightboxImage.onload = null;
    lightboxImage.onerror = null;
    
    // Preload image to check if it's available
    const preloadImage = new Image();
    
    preloadImage.onload = () => {
      // Image is available, set it to lightbox
      lightboxImage.src = src;
      lightboxImage.alt = alt;
      
      // Add event listeners
      lightboxImage.onload = newImageLoadHandler;
      lightboxImage.onerror = newImageErrorHandler;
      
      // If image is already cached, trigger load immediately
      if (lightboxImage.complete && lightboxImage.naturalHeight !== 0) {
        handleImageLoad();
      }
    };
    
    preloadImage.onerror = () => {
      handleImageError();
      lightboxImage.onerror = newImageErrorHandler;
    };
    
    // Start preloading
    preloadImage.src = src;
  }

  // Close lightbox
  function closeLightbox() {
    lightbox.classList.remove('active');
    document.body.style.overflow = '';
    currentScale = 1;
    lightboxImage.style.transform = `scale(${currentScale})`;
    // Reset image styles
    lightboxImage.style.opacity = '1';
    lightboxImage.style.visibility = 'visible';
    lightboxCaption.style.color = '#ffffff';
    // Clear image source to free memory
    setTimeout(() => {
      if (!lightbox.classList.contains('active')) {
        lightboxImage.src = '';
        lightboxImage.onload = null;
        lightboxImage.onerror = null;
      }
    }, 300);
  }

  // Zoom functions
  function zoomIn() {
    if (currentScale < maxScale) {
      currentScale = Math.min(currentScale + scaleStep, maxScale);
      lightboxImage.style.transform = `scale(${currentScale})`;
    }
  }

  function zoomOut() {
    if (currentScale > minScale) {
      currentScale = Math.max(currentScale - scaleStep, minScale);
      lightboxImage.style.transform = `scale(${currentScale})`;
    }
  }

  function resetZoom() {
    currentScale = 1;
    lightboxImage.style.transform = `scale(${currentScale})`;
  }

  // Function to attach click handlers to images
  function attachImageHandlers() {
    const images = document.querySelectorAll('.clickable-image, .post-content img, .post-image img');
    images.forEach(img => {
      // Skip if already processed
      if (img.dataset.lightboxAttached === 'true') return;
      
      img.style.cursor = 'zoom-in';
      img.dataset.lightboxAttached = 'true';
      img.addEventListener('click', function(e) {
        e.preventDefault();
        e.stopPropagation();
        openLightbox(this);
      });
    });
  }

  // Attach handlers on DOM ready
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', attachImageHandlers);
  } else {
    attachImageHandlers();
  }

  // Also attach handlers after a short delay to catch dynamically loaded images
  setTimeout(attachImageHandlers, 500);

  // Close events
  lightboxClose.addEventListener('click', closeLightbox);
  lightboxBackdrop.addEventListener('click', closeLightbox);

  // Zoom events
  zoomInBtn.addEventListener('click', zoomIn);
  zoomOutBtn.addEventListener('click', zoomOut);
  resetBtn.addEventListener('click', resetZoom);

  // Keyboard events
  document.addEventListener('keydown', function(e) {
    if (!lightbox.classList.contains('active')) return;

    switch(e.key) {
      case 'Escape':
        closeLightbox();
        break;
      case '+':
      case '=':
        zoomIn();
        break;
      case '-':
        zoomOut();
        break;
      case '0':
        resetZoom();
        break;
    }
  });

  // Mouse wheel zoom
  lightboxImage.addEventListener('wheel', function(e) {
    e.preventDefault();
    if (e.deltaY < 0) {
      zoomIn();
    } else {
      zoomOut();
    }
  });
})();
</script>

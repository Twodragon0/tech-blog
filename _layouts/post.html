---
layout: default
---
<div class="reading-progress" id="reading-progress"></div>

<article class="post-article" itemscope itemtype="http://schema.org/BlogPosting">
  <header class="post-header">
    {% if page.image %}
    <div class="post-image">
      <img src="{{ page.image | relative_url }}" alt="{{ page.title | escape }}" style="width:100%; height:auto; border-radius:8px; margin-bottom: 20px;">
    </div>
    {% endif %}

    {% if page.category %}
    <div class="post-category">
      <a href="{{ '/categories/' | relative_url }}#{{ page.category | downcase }}" class="category-badge {{ page.category | downcase }}">
        {{ page.category }}
      </a>
    </div>
    {% elsif page.categories.first %}
    <div class="post-category">
      <a href="{{ '/categories/' | relative_url }}#{{ page.categories.first | downcase | replace: ' ', '-' }}" class="category-badge {{ page.categories.first | downcase | replace: ' ', '-' }}">
        {{ page.categories.first }}
      </a>
    </div>
    {% endif %}

    <h1 class="post-title" itemprop="name headline">{{ page.title | escape }}</h1>

    <div class="post-meta">
      <span class="meta-item">
        <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
          <rect x="3" y="4" width="18" height="18" rx="2" ry="2"/>
          <line x1="16" y1="2" x2="16" y2="6"/>
          <line x1="8" y1="2" x2="8" y2="6"/>
          <line x1="3" y1="10" x2="21" y2="10"/>
        </svg>
        <time class="dt-published" datetime="{{ page.date | date_to_xmlschema }}" itemprop="datePublished">
          {{ page.date | date: "%Y. %m. %d" }}
        </time>
      </span>

      <span class="meta-item">
        <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
          <circle cx="12" cy="12" r="10"/>
          <polyline points="12 6 12 12 16 14"/>
        </svg>
        <span id="reading-time"></span>
      </span>

      <span class="meta-item" itemprop="author" itemscope itemtype="http://schema.org/Person">
        <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
          <path d="M20 21v-2a4 4 0 0 0-4-4H8a4 4 0 0 0-4 4v2"/>
          <circle cx="12" cy="7" r="4"/>
        </svg>
        <span itemprop="name">{{ site.author.name }}</span>
      </span>
    </div>

    {% if page.tags.size > 0 %}
    <div class="post-tags">
      {% for tag in page.tags %}
      <a href="{{ '/tags/' | relative_url }}#{{ tag | slugify }}" class="tag">{{ tag }}</a>
      {% endfor %}
    </div>
    {% endif %}

    <!-- Language Selector & Translate Button -->
    <div class="language-tools">
      <div class="language-selector">
        <button class="lang-btn active" data-lang="ko" title="í•œêµ­ì–´">
          <span class="lang-flag">ğŸ‡°ğŸ‡·</span>
          <span class="lang-name">í•œêµ­ì–´</span>
        </button>
        <button class="lang-btn" data-lang="en" title="English">
          <span class="lang-flag">ğŸ‡ºğŸ‡¸</span>
          <span class="lang-name">English</span>
        </button>
        <button class="lang-btn" data-lang="ja" title="æ—¥æœ¬èª">
          <span class="lang-flag">ğŸ‡¯ğŸ‡µ</span>
          <span class="lang-name">æ—¥æœ¬èª</span>
        </button>
        <button class="lang-btn" data-lang="zh" title="ä¸­æ–‡">
          <span class="lang-flag">ğŸ‡¨ğŸ‡³</span>
          <span class="lang-name">ä¸­æ–‡</span>
        </button>
        <a href="#" id="google-translate-link" class="translate-external" title="Google ë²ˆì—­ìœ¼ë¡œ ì—´ê¸°" target="_blank" rel="noopener">
          <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
            <path d="M18 13v6a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h6"/>
            <polyline points="15 3 21 3 21 9"/>
            <line x1="10" y1="14" x2="21" y2="3"/>
          </svg>
          <span>Google ë²ˆì—­</span>
        </a>
      </div>
      <div class="translate-status" id="translate-status"></div>
    </div>
  </header>

  {% if page.toc %}
  {% include toc.html content=content %}
  {% endif %}

  <div class="post-content" itemprop="articleBody">
    {{ content }}
  </div>

  <footer class="post-footer">
    {% if page.original_url %}
    <a href="{{ page.original_url }}" target="_blank" rel="noopener noreferrer" class="original-link">
      <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
        <path d="M18 13v6a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h6"/>
        <polyline points="15 3 21 3 21 9"/>
        <line x1="10" y1="14" x2="21" y2="3"/>
      </svg>
      ì›ë³¸ í¬ìŠ¤íŠ¸ ë³´ê¸°
    </a>
    {% endif %}

    {% include share-buttons.html %}
  </footer>

  {% assign posts = site.posts | where_exp: "post", "post.url != page.url" %}
  {% if page.category %}
    {% assign related = posts | where: "category", page.category | limit: 4 %}
  {% elsif page.categories.first %}
    {% assign cat = page.categories.first %}
    {% assign related = posts | where_exp: "post", "post.categories contains cat" | limit: 4 %}
  {% else %}
    {% assign related = posts | limit: 4 %}
  {% endif %}

  {% if related.size > 0 %}
  <section class="related-posts">
    <h3>Related Posts</h3>
    <div class="related-grid">
      {% for post in related limit: 4 %}
      <a href="{{ post.url | relative_url }}" class="related-item card">
        <h4>{{ post.title | escape }}</h4>
        <span class="related-date">{{ post.date | date: "%Y. %m. %d" }}</span>
      </a>
      {% endfor %}
    </div>
  </section>
  {% endif %}

  {% include giscus.html %}
</article>

<script>
// Reading time calculation
document.addEventListener('DOMContentLoaded', function() {
  const content = document.querySelector('.post-content');
  if (content) {
    const text = content.textContent || content.innerText;
    const wordCount = text.trim().split(/\s+/).length;
    const readingTime = Math.ceil(wordCount / 200);
    document.getElementById('reading-time').textContent = readingTime + ' min read';
  }
});

// Reading progress bar
window.addEventListener('scroll', function() {
  const article = document.querySelector('.post-article');
  const progressBar = document.getElementById('reading-progress');
  if (article && progressBar) {
    const articleTop = article.offsetTop;
    const articleHeight = article.offsetHeight;
    const windowHeight = window.innerHeight;
    const scrollY = window.scrollY;
    const progress = Math.min(Math.max((scrollY - articleTop + windowHeight * 0.3) / articleHeight * 100, 0), 100);
    progressBar.style.width = progress + '%';
  }
});

// Giscus loading state management
document.addEventListener('DOMContentLoaded', function() {
  const giscusContainer = document.getElementById('giscus-container');
  const giscusLoading = document.getElementById('giscus-loading');
  
  if (giscusContainer && giscusLoading) {
    // Giscusê°€ ë¡œë“œë˜ë©´ ë¡œë”© ì¸ë””ì¼€ì´í„° ìˆ¨ê¸°ê¸°
    const observer = new MutationObserver(function(mutations) {
      const giscusFrame = giscusContainer.querySelector('iframe');
      if (giscusFrame && giscusFrame.contentDocument) {
        giscusLoading.classList.add('hidden');
        observer.disconnect();
      }
    });

    observer.observe(giscusContainer, {
      childList: true,
      subtree: true
    });

    // ìµœëŒ€ ëŒ€ê¸° ì‹œê°„ ì„¤ì • (10ì´ˆ í›„ ìë™ìœ¼ë¡œ ë¡œë”© ì¸ë””ì¼€ì´í„° ìˆ¨ê¸°ê¸°)
    setTimeout(function() {
      if (!giscusLoading.classList.contains('hidden')) {
        giscusLoading.classList.add('hidden');
      }
    }, 10000);

    // Giscus ìŠ¤í¬ë¦½íŠ¸ ë¡œë“œ í™•ì¸
    const giscusScript = document.querySelector('script[src*="giscus.app"]');
    if (giscusScript) {
      giscusScript.addEventListener('load', function() {
        // ìŠ¤í¬ë¦½íŠ¸ ë¡œë“œ í›„ ì§§ì€ ì§€ì—°ì„ ë‘ê³  í™•ì¸
        setTimeout(function() {
          const giscusFrame = giscusContainer.querySelector('iframe');
          if (giscusFrame) {
            giscusLoading.classList.add('hidden');
          }
        }, 2000);
      });
    }
  }
});

// Translation functionality using Google Translate
(function() {
  const langButtons = document.querySelectorAll('.lang-btn');
  const translateStatus = document.getElementById('translate-status');
  const postContent = document.querySelector('.post-content');
  const postTitle = document.querySelector('.post-title');
  const googleTranslateLink = document.getElementById('google-translate-link');

  let originalContent = null;
  let originalTitle = null;
  let currentLang = 'ko';
  let translationCache = {};

  // Set Google Translate link
  if (googleTranslateLink) {
    googleTranslateLink.href = `https://translate.google.com/translate?sl=ko&tl=en&u=${encodeURIComponent(window.location.href)}`;
  }

  // Save original content
  if (postContent) {
    originalContent = postContent.innerHTML;
  }
  if (postTitle) {
    originalTitle = postTitle.textContent;
  }

  // Language button click handler
  langButtons.forEach(btn => {
    btn.addEventListener('click', async function() {
      const targetLang = this.dataset.lang;

      if (targetLang === currentLang) return;

      // Update active button
      langButtons.forEach(b => b.classList.remove('active'));
      this.classList.add('active');

      // Show loading status
      showStatus('ë²ˆì—­ ì¤‘...', 'loading');

      try {
        if (targetLang === 'ko') {
          // Restore original Korean content
          if (originalContent) postContent.innerHTML = originalContent;
          if (originalTitle) postTitle.textContent = originalTitle;
          currentLang = 'ko';
          showStatus('ì›ë³¸ìœ¼ë¡œ ë³µì›ë˜ì—ˆìŠµë‹ˆë‹¤', 'success');
        } else {
          // Translate to target language
          await translatePage(targetLang);
          currentLang = targetLang;
          showStatus(getLanguageName(targetLang) + 'ë¡œ ë²ˆì—­ë˜ì—ˆìŠµë‹ˆë‹¤', 'success');
        }
      } catch (error) {
        console.error('Translation error:', error);
        showStatus('ë²ˆì—­ ì‹¤íŒ¨. ë‹¤ì‹œ ì‹œë„í•´ì£¼ì„¸ìš”.', 'error');
      }
    });
  });

  async function translatePage(targetLang) {
    // Check cache first
    const cacheKey = targetLang;
    if (translationCache[cacheKey]) {
      if (translationCache[cacheKey].content) {
        postContent.innerHTML = translationCache[cacheKey].content;
      }
      if (translationCache[cacheKey].title) {
        postTitle.textContent = translationCache[cacheKey].title;
      }
      return;
    }

    // Use Google Translate widget approach (free, no API key needed)
    const translateUrl = `https://translate.google.com/translate?sl=ko&tl=${targetLang}&u=${encodeURIComponent(window.location.href)}`;

    // For inline translation, we'll use a different approach
    // Create a temporary iframe or use the LibreTranslate API

    // Alternative: Use browser's built-in translation hint
    // or redirect to Google Translate

    // Simple approach: Open Google Translate in new tab with option
    const useRedirect = false; // Set to true to redirect to Google Translate

    if (useRedirect) {
      window.open(translateUrl, '_blank');
      return;
    }

    // Inline translation using free API (MyMemory Translation API)
    await translateInline(targetLang);
  }

  async function translateInline(targetLang) {
    // Get text content to translate
    const textElements = postContent.querySelectorAll('p, h1, h2, h3, h4, h5, h6, li, td, th, blockquote, .summary-value, .summary-list li');

    const langMap = {
      'en': 'en-US',
      'ja': 'ja-JP',
      'zh': 'zh-CN'
    };

    const targetLangCode = langMap[targetLang] || targetLang;

    // Translate title
    if (postTitle && originalTitle) {
      const translatedTitle = await translateText(originalTitle, 'ko', targetLangCode);
      if (translatedTitle) {
        postTitle.textContent = translatedTitle;
      }
    }

    // Batch translate content
    const textsToTranslate = [];
    const elementsMap = [];

    textElements.forEach((el, index) => {
      const text = el.textContent.trim();
      if (text && text.length > 0 && text.length < 500) {
        textsToTranslate.push(text);
        elementsMap.push({ element: el, index: textsToTranslate.length - 1 });
      }
    });

    // Translate in batches
    const batchSize = 10;
    for (let i = 0; i < textsToTranslate.length; i += batchSize) {
      const batch = textsToTranslate.slice(i, i + batchSize);
      const translations = await Promise.all(
        batch.map(text => translateText(text, 'ko', targetLangCode))
      );

      translations.forEach((translated, j) => {
        const mapIndex = i + j;
        const item = elementsMap.find(m => m.index === mapIndex);
        if (item && translated) {
          // Preserve HTML structure, only replace text
          if (item.element.children.length === 0) {
            item.element.textContent = translated;
          }
        }
      });

      // Update progress
      const progress = Math.min(100, Math.round(((i + batchSize) / textsToTranslate.length) * 100));
      showStatus(`ë²ˆì—­ ì¤‘... ${progress}%`, 'loading');
    }

    // Cache the translation
    translationCache[targetLang] = {
      content: postContent.innerHTML,
      title: postTitle ? postTitle.textContent : null
    };
  }

  async function translateText(text, sourceLang, targetLang) {
    try {
      // Using MyMemory Translation API (free, 1000 words/day limit)
      const response = await fetch(
        `https://api.mymemory.translated.net/get?q=${encodeURIComponent(text)}&langpair=${sourceLang}|${targetLang}`
      );

      if (!response.ok) throw new Error('Translation API error');

      const data = await response.json();

      if (data.responseStatus === 200 && data.responseData) {
        return data.responseData.translatedText;
      }

      return null;
    } catch (error) {
      console.warn('Translation failed for:', text.substring(0, 50));
      return null;
    }
  }

  function showStatus(message, type) {
    if (!translateStatus) return;

    translateStatus.textContent = message;
    translateStatus.className = 'translate-status ' + type;

    if (type === 'success' || type === 'error') {
      setTimeout(() => {
        translateStatus.textContent = '';
        translateStatus.className = 'translate-status';
      }, 3000);
    }
  }

  function getLanguageName(lang) {
    const names = {
      'ko': 'í•œêµ­ì–´',
      'en': 'English',
      'ja': 'æ—¥æœ¬èª',
      'zh': 'ä¸­æ–‡'
    };
    return names[lang] || lang;
  }
})();
</script>

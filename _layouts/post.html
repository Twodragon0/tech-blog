---
layout: default
---
<div class="reading-progress" id="reading-progress"></div>

<article class="post-article" itemscope itemtype="http://schema.org/BlogPosting">
  <header class="post-header">
    {% if page.image %}
    <div class="post-image">
      <img src="{{ page.image | relative_url }}" alt="{{ page.title | escape }}" class="clickable-image" data-full-src="{{ page.image | relative_url }}" style="width:100%; height:auto; border-radius:8px; margin-bottom: 20px; cursor: zoom-in;">
    </div>
    {% endif %}

    {% if page.category %}
    <div class="post-category">
      <a href="{{ '/categories/' | relative_url }}#{{ page.category | downcase }}" class="category-badge {{ page.category | downcase }}">
        {{ page.category }}
      </a>
    </div>
    {% elsif page.categories.first %}
    <div class="post-category">
      <a href="{{ '/categories/' | relative_url }}#{{ page.categories.first | downcase | replace: ' ', '-' }}" class="category-badge {{ page.categories.first | downcase | replace: ' ', '-' }}">
        {{ page.categories.first }}
      </a>
    </div>
    {% endif %}

    <h1 class="post-title" itemprop="name headline">{{ page.title | escape }}</h1>

    <div class="post-meta">
      <span class="meta-item">
        <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
          <rect x="3" y="4" width="18" height="18" rx="2" ry="2"/>
          <line x1="16" y1="2" x2="16" y2="6"/>
          <line x1="8" y1="2" x2="8" y2="6"/>
          <line x1="3" y1="10" x2="21" y2="10"/>
        </svg>
        <time class="dt-published" datetime="{{ page.date | date_to_xmlschema }}" itemprop="datePublished">
          {{ page.date | date: "%Y. %m. %d" }}
        </time>
      </span>

      <span class="meta-item">
        <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
          <circle cx="12" cy="12" r="10"/>
          <polyline points="12 6 12 12 16 14"/>
        </svg>
        <span id="reading-time"></span>
      </span>

      <span class="meta-item" itemprop="author" itemscope itemtype="http://schema.org/Person">
        <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
          <path d="M20 21v-2a4 4 0 0 0-4-4H8a4 4 0 0 0-4 4v2"/>
          <circle cx="12" cy="7" r="4"/>
        </svg>
        <span itemprop="name">{{ site.author.name }}</span>
      </span>
    </div>

    {% if page.tags.size > 0 %}
    <div class="post-tags">
      {% for tag in page.tags %}
      <a href="{{ '/tags/' | relative_url }}#{{ tag | slugify }}" class="tag">{{ tag }}</a>
      {% endfor %}
    </div>
    {% endif %}

    <!-- Language Selector & Translate Button -->
    <div class="language-tools">
      <div class="language-selector">
        <button class="lang-btn active" data-lang="ko" title="ÌïúÍµ≠Ïñ¥">
          <span class="lang-flag">üá∞üá∑</span>
          <span class="lang-name">ÌïúÍµ≠Ïñ¥</span>
        </button>
        <button class="lang-btn" data-lang="en" title="English">
          <span class="lang-flag">üá∫üá∏</span>
          <span class="lang-name">English</span>
        </button>
        <button class="lang-btn" data-lang="ja" title="Êó•Êú¨Ë™û">
          <span class="lang-flag">üáØüáµ</span>
          <span class="lang-name">Êó•Êú¨Ë™û</span>
        </button>
        <button class="lang-btn" data-lang="zh" title="‰∏≠Êñá">
          <span class="lang-flag">üá®üá≥</span>
          <span class="lang-name">‰∏≠Êñá</span>
        </button>
        <a href="#" id="google-translate-link" class="translate-external" title="Google Î≤àÏó≠ÏúºÎ°ú Ïó¥Í∏∞" target="_blank" rel="noopener">
          <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
            <path d="M18 13v6a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h6"/>
            <polyline points="15 3 21 3 21 9"/>
            <line x1="10" y1="14" x2="21" y2="3"/>
          </svg>
          <span>Google Î≤àÏó≠</span>
        </a>
      </div>
      <div class="translate-status" id="translate-status"></div>
    </div>
  </header>

  {% if page.toc %}
  {% include toc.html content=content %}
  {% endif %}

  <div class="post-content" itemprop="articleBody">
    {{ content }}
  </div>

  <footer class="post-footer">
    {% if page.original_url %}
    <a href="{{ page.original_url }}" target="_blank" rel="noopener noreferrer" class="original-link">
      <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
        <path d="M18 13v6a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h6"/>
        <polyline points="15 3 21 3 21 9"/>
        <line x1="10" y1="14" x2="21" y2="3"/>
      </svg>
      ÏõêÎ≥∏ Ìè¨Ïä§Ìä∏ Î≥¥Í∏∞
    </a>
    {% endif %}

    {% include share-buttons.html %}
  </footer>

  {% assign posts = site.posts | where_exp: "post", "post.url != page.url" %}
  {% if page.category %}
    {% assign related = posts | where: "category", page.category | limit: 4 %}
  {% elsif page.categories.first %}
    {% assign cat = page.categories.first %}
    {% assign related = posts | where_exp: "post", "post.categories contains cat" | limit: 4 %}
  {% else %}
    {% assign related = posts | limit: 4 %}
  {% endif %}

  {% if related.size > 0 %}
  <section class="related-posts">
    <h3>Related Posts</h3>
    <div class="related-grid">
      {% for post in related limit: 4 %}
      <a href="{{ post.url | relative_url }}" class="related-item card">
        <h4>{{ post.title | escape }}</h4>
        <span class="related-date">{{ post.date | date: "%Y. %m. %d" }}</span>
      </a>
      {% endfor %}
    </div>
  </section>
  {% endif %}

  {% include giscus.html %}
</article>

<script>
// Reading time calculation
document.addEventListener('DOMContentLoaded', function() {
  const content = document.querySelector('.post-content');
  if (content) {
    const text = content.textContent || content.innerText;
    const wordCount = text.trim().split(/\s+/).length;
    const readingTime = Math.ceil(wordCount / 200);
    document.getElementById('reading-time').textContent = readingTime + ' min read';
  }
});

// Reading progress bar
window.addEventListener('scroll', function() {
  const article = document.querySelector('.post-article');
  const progressBar = document.getElementById('reading-progress');
  if (article && progressBar) {
    const articleTop = article.offsetTop;
    const articleHeight = article.offsetHeight;
    const windowHeight = window.innerHeight;
    const scrollY = window.scrollY;
    const progress = Math.min(Math.max((scrollY - articleTop + windowHeight * 0.3) / articleHeight * 100, 0), 100);
    progressBar.style.width = progress + '%';
  }
});

// Giscus loading state management
document.addEventListener('DOMContentLoaded', function() {
  const giscusContainer = document.getElementById('giscus-container');
  const giscusLoading = document.getElementById('giscus-loading');
  
  if (giscusContainer && giscusLoading) {
    // GiscusÍ∞Ä Î°úÎìúÎêòÎ©¥ Î°úÎî© Ïù∏ÎîîÏºÄÏù¥ÌÑ∞ Ïà®Í∏∞Í∏∞
    const observer = new MutationObserver(function(mutations) {
      const giscusFrame = giscusContainer.querySelector('iframe');
      if (giscusFrame && giscusFrame.contentDocument) {
        giscusLoading.classList.add('hidden');
        observer.disconnect();
      }
    });

    observer.observe(giscusContainer, {
      childList: true,
      subtree: true
    });

    // ÏµúÎåÄ ÎåÄÍ∏∞ ÏãúÍ∞Ñ ÏÑ§Ï†ï (10Ï¥à ÌõÑ ÏûêÎèôÏúºÎ°ú Î°úÎî© Ïù∏ÎîîÏºÄÏù¥ÌÑ∞ Ïà®Í∏∞Í∏∞)
    setTimeout(function() {
      if (!giscusLoading.classList.contains('hidden')) {
        giscusLoading.classList.add('hidden');
      }
    }, 10000);

    // Giscus Ïä§ÌÅ¨Î¶ΩÌä∏ Î°úÎìú ÌôïÏù∏
    const giscusScript = document.querySelector('script[src*="giscus.app"]');
    if (giscusScript) {
      giscusScript.addEventListener('load', function() {
        // Ïä§ÌÅ¨Î¶ΩÌä∏ Î°úÎìú ÌõÑ ÏßßÏùÄ ÏßÄÏó∞ÏùÑ ÎëêÍ≥† ÌôïÏù∏
        setTimeout(function() {
          const giscusFrame = giscusContainer.querySelector('iframe');
          if (giscusFrame) {
            giscusLoading.classList.add('hidden');
          }
        }, 2000);
      });
    }
  }
});

// Translation functionality using Google Translate
(function() {
  const langButtons = document.querySelectorAll('.lang-btn');
  const translateStatus = document.getElementById('translate-status');
  const postContent = document.querySelector('.post-content');
  const postTitle = document.querySelector('.post-title');
  const googleTranslateLink = document.getElementById('google-translate-link');

  let originalContent = null;
  let originalTitle = null;
  let currentLang = 'ko';
  let translationCache = {};

  // Set Google Translate link
  if (googleTranslateLink) {
    googleTranslateLink.href = `https://translate.google.com/translate?sl=ko&tl=en&u=${encodeURIComponent(window.location.href)}`;
  }

  // Save original content
  if (postContent) {
    originalContent = postContent.innerHTML;
  }
  if (postTitle) {
    originalTitle = postTitle.textContent;
  }

  // Language button click handler
  langButtons.forEach(btn => {
    btn.addEventListener('click', async function() {
      const targetLang = this.dataset.lang;

      if (targetLang === currentLang) return;

      // Update active button
      langButtons.forEach(b => b.classList.remove('active'));
      this.classList.add('active');

      // Show loading status
      showStatus('Î≤àÏó≠ Ï§ë...', 'loading');

      try {
        if (targetLang === 'ko') {
          // Restore original Korean content
          if (originalContent) postContent.innerHTML = originalContent;
          if (originalTitle) postTitle.textContent = originalTitle;
          currentLang = 'ko';
          showStatus('ÏõêÎ≥∏ÏúºÎ°ú Î≥µÏõêÎêòÏóàÏäµÎãàÎã§', 'success');
        } else {
          // Translate to target language
          await translatePage(targetLang);
          currentLang = targetLang;
          showStatus(getLanguageName(targetLang) + 'Î°ú Î≤àÏó≠ÎêòÏóàÏäµÎãàÎã§', 'success');
        }
      } catch (error) {
        console.error('Translation error:', error);
        showStatus('Î≤àÏó≠ Ïã§Ìå®. Îã§Ïãú ÏãúÎèÑÌï¥Ï£ºÏÑ∏Ïöî.', 'error');
      }
    });
  });

  async function translatePage(targetLang) {
    // Check cache first
    const cacheKey = targetLang;
    if (translationCache[cacheKey]) {
      if (translationCache[cacheKey].content) {
        postContent.innerHTML = translationCache[cacheKey].content;
      }
      if (translationCache[cacheKey].title) {
        postTitle.textContent = translationCache[cacheKey].title;
      }
      return;
    }

    // Use Google Translate widget approach (free, no API key needed)
    const translateUrl = `https://translate.google.com/translate?sl=ko&tl=${targetLang}&u=${encodeURIComponent(window.location.href)}`;

    // For inline translation, we'll use a different approach
    // Create a temporary iframe or use the LibreTranslate API

    // Alternative: Use browser's built-in translation hint
    // or redirect to Google Translate

    // Simple approach: Open Google Translate in new tab with option
    const useRedirect = false; // Set to true to redirect to Google Translate

    if (useRedirect) {
      window.open(translateUrl, '_blank');
      return;
    }

    // Inline translation using free API (MyMemory Translation API)
    await translateInline(targetLang);
  }

  async function translateInline(targetLang) {
    // Get text content to translate
    const textElements = postContent.querySelectorAll('p, h1, h2, h3, h4, h5, h6, li, td, th, blockquote, .summary-value, .summary-list li');

    const langMap = {
      'en': 'en-US',
      'ja': 'ja-JP',
      'zh': 'zh-CN'
    };

    const targetLangCode = langMap[targetLang] || targetLang;

    // Translate title
    if (postTitle && originalTitle) {
      const translatedTitle = await translateText(originalTitle, 'ko', targetLangCode);
      if (translatedTitle) {
        postTitle.textContent = translatedTitle;
      }
    }

    // Batch translate content
    const textsToTranslate = [];
    const elementsMap = [];

    textElements.forEach((el, index) => {
      const text = el.textContent.trim();
      if (text && text.length > 0 && text.length < 500) {
        textsToTranslate.push(text);
        elementsMap.push({ element: el, index: textsToTranslate.length - 1 });
      }
    });

    // Translate in batches
    const batchSize = 10;
    for (let i = 0; i < textsToTranslate.length; i += batchSize) {
      const batch = textsToTranslate.slice(i, i + batchSize);
      const translations = await Promise.all(
        batch.map(text => translateText(text, 'ko', targetLangCode))
      );

      translations.forEach((translated, j) => {
        const mapIndex = i + j;
        const item = elementsMap.find(m => m.index === mapIndex);
        if (item && translated) {
          // Preserve HTML structure, only replace text
          if (item.element.children.length === 0) {
            item.element.textContent = translated;
          }
        }
      });

      // Update progress
      const progress = Math.min(100, Math.round(((i + batchSize) / textsToTranslate.length) * 100));
      showStatus(`Î≤àÏó≠ Ï§ë... ${progress}%`, 'loading');
    }

    // Cache the translation
    translationCache[targetLang] = {
      content: postContent.innerHTML,
      title: postTitle ? postTitle.textContent : null
    };
  }

  async function translateText(text, sourceLang, targetLang) {
    try {
      // Using MyMemory Translation API (free, 1000 words/day limit)
      const response = await fetch(
        `https://api.mymemory.translated.net/get?q=${encodeURIComponent(text)}&langpair=${sourceLang}|${targetLang}`
      );

      if (!response.ok) throw new Error('Translation API error');

      const data = await response.json();

      if (data.responseStatus === 200 && data.responseData) {
        return data.responseData.translatedText;
      }

      return null;
    } catch (error) {
      console.warn('Translation failed for:', text.substring(0, 50));
      return null;
    }
  }

  function showStatus(message, type) {
    if (!translateStatus) return;

    translateStatus.textContent = message;
    translateStatus.className = 'translate-status ' + type;

    if (type === 'success' || type === 'error') {
      setTimeout(() => {
        translateStatus.textContent = '';
        translateStatus.className = 'translate-status';
      }, 3000);
    }
  }

  function getLanguageName(lang) {
    const names = {
      'ko': 'ÌïúÍµ≠Ïñ¥',
      'en': 'English',
      'ja': 'Êó•Êú¨Ë™û',
      'zh': '‰∏≠Êñá'
    };
    return names[lang] || lang;
  }
})();

// Image Lightbox functionality
(function() {
  // Create lightbox elements
  const lightbox = document.createElement('div');
  lightbox.id = 'image-lightbox';
  lightbox.className = 'image-lightbox';
  lightbox.innerHTML = `
    <div class="lightbox-backdrop"></div>
    <div class="lightbox-content">
      <button class="lightbox-close" aria-label="Îã´Í∏∞">
        <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
          <line x1="18" y1="6" x2="6" y2="18"/>
          <line x1="6" y1="6" x2="18" y2="18"/>
        </svg>
      </button>
      <img class="lightbox-image" src="" alt="">
      <div class="lightbox-caption"></div>
      <div class="lightbox-controls">
        <button class="lightbox-zoom-in" aria-label="ÌôïÎåÄ">
          <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
            <circle cx="11" cy="11" r="8"/>
            <line x1="21" y1="21" x2="16.65" y2="16.65"/>
            <line x1="11" y1="8" x2="11" y2="14"/>
            <line x1="8" y1="11" x2="14" y2="11"/>
          </svg>
        </button>
        <button class="lightbox-zoom-out" aria-label="Ï∂ïÏÜå">
          <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
            <circle cx="11" cy="11" r="8"/>
            <line x1="21" y1="21" x2="16.65" y2="16.65"/>
            <line x1="8" y1="11" x2="14" y2="11"/>
          </svg>
        </button>
        <button class="lightbox-reset" aria-label="ÏõêÎ≥∏ ÌÅ¨Í∏∞">
          <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
            <polyline points="15 3 21 3 21 9"/>
            <polyline points="9 21 3 21 3 15"/>
            <line x1="21" y1="3" x2="14" y2="10"/>
            <line x1="3" y1="21" x2="10" y2="14"/>
          </svg>
        </button>
      </div>
    </div>
  `;
  document.body.appendChild(lightbox);

  const lightboxImage = lightbox.querySelector('.lightbox-image');
  const lightboxCaption = lightbox.querySelector('.lightbox-caption');
  const lightboxClose = lightbox.querySelector('.lightbox-close');
  const lightboxBackdrop = lightbox.querySelector('.lightbox-backdrop');
  const zoomInBtn = lightbox.querySelector('.lightbox-zoom-in');
  const zoomOutBtn = lightbox.querySelector('.lightbox-zoom-out');
  const resetBtn = lightbox.querySelector('.lightbox-reset');

  let currentScale = 1;
  const scaleStep = 0.25;
  const maxScale = 3;
  const minScale = 0.5;

  // Open lightbox on image click
  function openLightbox(img) {
    const src = img.dataset.fullSrc || img.src;
    const alt = img.alt || '';

    lightboxImage.src = src;
    lightboxImage.alt = alt;
    lightboxCaption.textContent = alt;
    currentScale = 1;
    lightboxImage.style.transform = `scale(${currentScale})`;

    lightbox.classList.add('active');
    document.body.style.overflow = 'hidden';
  }

  // Close lightbox
  function closeLightbox() {
    lightbox.classList.remove('active');
    document.body.style.overflow = '';
    currentScale = 1;
    lightboxImage.style.transform = `scale(${currentScale})`;
  }

  // Zoom functions
  function zoomIn() {
    if (currentScale < maxScale) {
      currentScale = Math.min(currentScale + scaleStep, maxScale);
      lightboxImage.style.transform = `scale(${currentScale})`;
    }
  }

  function zoomOut() {
    if (currentScale > minScale) {
      currentScale = Math.max(currentScale - scaleStep, minScale);
      lightboxImage.style.transform = `scale(${currentScale})`;
    }
  }

  function resetZoom() {
    currentScale = 1;
    lightboxImage.style.transform = `scale(${currentScale})`;
  }

  // Event listeners for clickable images
  document.querySelectorAll('.clickable-image, .post-content img, .post-image img').forEach(img => {
    img.style.cursor = 'zoom-in';
    img.addEventListener('click', function(e) {
      e.preventDefault();
      openLightbox(this);
    });
  });

  // Close events
  lightboxClose.addEventListener('click', closeLightbox);
  lightboxBackdrop.addEventListener('click', closeLightbox);

  // Zoom events
  zoomInBtn.addEventListener('click', zoomIn);
  zoomOutBtn.addEventListener('click', zoomOut);
  resetBtn.addEventListener('click', resetZoom);

  // Keyboard events
  document.addEventListener('keydown', function(e) {
    if (!lightbox.classList.contains('active')) return;

    switch(e.key) {
      case 'Escape':
        closeLightbox();
        break;
      case '+':
      case '=':
        zoomIn();
        break;
      case '-':
        zoomOut();
        break;
      case '0':
        resetZoom();
        break;
    }
  });

  // Mouse wheel zoom
  lightboxImage.addEventListener('wheel', function(e) {
    e.preventDefault();
    if (e.deltaY < 0) {
      zoomIn();
    } else {
      zoomOut();
    }
  });
})();
</script>

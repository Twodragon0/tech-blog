name: Sentry Issue Resolution

# Sentry ì´ìŠˆ í•´ê²° ì›Œí¬í”Œë¡œìš°
# Free í‹°ì–´ ìµœì í™”: continue-on-error, ê°„ë‹¨í•œ ì—ëŸ¬ ì²˜ë¦¬
# ë‘ ê°€ì§€ íŠ¸ë¦¬ê±°:
#   1. workflow_dispatch: íŠ¹ì • ì´ìŠˆ ìˆ˜ë™ í•´ê²° (TECH-BLOG-4 í˜•ì‹)
#   2. push to main: ë°°í¬ ì‹œ ì˜¤ë˜ëœ ë¯¸í•´ê²° ì´ìŠˆ ìë™ í•´ê²°

on:
  push:
    branches:
      - main
    paths:
      - '_includes/**'
      - '_layouts/**'
      - '_posts/**'
      - 'assets/**'
      - '_config.yml'
      - 'vercel.json'
  workflow_dispatch:
    inputs:
      issue_id:
        description: 'Issue short ID (e.g., TECH-BLOG-4)'
        required: true
        type: string
      status:
        description: 'Resolution status'
        required: false
        default: 'resolved'
        type: choice
        options:
          - 'resolved'
          - 'ignored'

concurrency:
  group: sentry-resolve-${{ github.ref }}
  cancel-in-progress: true

jobs:
  resolve-issue:
    if: github.event_name == 'workflow_dispatch'
    runs-on: ubuntu-latest
    timeout-minutes: 3
    continue-on-error: true

    permissions:
      contents: read

    steps:
      - name: Resolve Sentry Issue
        env:
          SENTRY_AUTH_TOKEN: ${{ secrets.SENTRY_AUTH_TOKEN }}
          SENTRY_ORG: ${{ secrets.SENTRY_ORG || 'twodragon' }}
          SENTRY_PROJECT: ${{ secrets.SENTRY_PROJECT || 'tech-blog' }}
          ISSUE_ID: ${{ github.event.inputs.issue_id }}
          STATUS: ${{ github.event.inputs.status }}
        run: |
          # â”€â”€â”€ Reusable curl-retry function â”€â”€â”€
          sentry_api() {
            local url="$1"
            local method="${2:-GET}"
            local data="${3:-}"
            local max_retries=3
            local retry=0
            local http_code=""
            local body=""
            local response=""

            while [ $retry -lt $max_retries ]; do
              if [ -n "$data" ]; then
                response=$(curl -s --max-time 15 -w "\n%{http_code}" \
                  -X "$method" \
                  -H "Authorization: Bearer $SENTRY_AUTH_TOKEN" \
                  -H "Content-Type: application/json" \
                  -d "$data" \
                  "$url" 2>&1)
              else
                response=$(curl -s --max-time 15 -w "\n%{http_code}" \
                  -X "$method" \
                  -H "Authorization: Bearer $SENTRY_AUTH_TOKEN" \
                  -H "Content-Type: application/json" \
                  "$url" 2>&1)
              fi
              local exit_code=$?

              http_code=$(echo "$response" | tail -n1)
              body=$(echo "$response" | sed '$d')

              if [ "$exit_code" -eq 0 ] && echo "$http_code" | grep -qE '^[0-9]{3}$'; then
                echo "$body"
                return 0
              fi

              retry=$((retry + 1))
              if [ $retry -lt $max_retries ]; then
                echo "âš ï¸  Retry $retry/$max_retries (curl exit: $exit_code)..." >&2
                sleep $((retry + 1))
              fi
            done

            echo "NETWORK_ERROR"
            return 0
          }

          echo "ğŸ” Looking up issue: $ISSUE_ID"

          # Token í™•ì¸
          if [ -z "$SENTRY_AUTH_TOKEN" ]; then
            echo "âŒ SENTRY_AUTH_TOKEN not set"
            exit 1
          fi

          # Step 1: Lookup issue by short ID (project-level API with shortIdLookup)
          LOOKUP_URL="https://sentry.io/api/0/projects/$SENTRY_ORG/$SENTRY_PROJECT/issues/?query=$ISSUE_ID&shortIdLookup=1"
          echo "ğŸ“¡ API: $LOOKUP_URL"
          LOOKUP_RESPONSE=$(sentry_api "$LOOKUP_URL") || true

          if [ "$LOOKUP_RESPONSE" = "NETWORK_ERROR" ]; then
            echo "âŒ Network error looking up issue"
            exit 1
          fi

          echo "ğŸ“‹ Response (first 300 chars): $(echo "$LOOKUP_RESPONSE" | head -c 300)"

          # Extract numeric issue ID - try multiple patterns
          ISSUE_NUMERIC_ID=$(echo "$LOOKUP_RESPONSE" | grep -oP '"id"\s*:\s*"?\K[0-9]+' | head -1 || true)

          # Fallback: simpler grep
          if [ -z "$ISSUE_NUMERIC_ID" ]; then
            ISSUE_NUMERIC_ID=$(echo "$LOOKUP_RESPONSE" | grep -o '"id":"[0-9]*"' | head -1 | grep -o '[0-9]*' || true)
          fi

          # Fallback: try without quotes on id value
          if [ -z "$ISSUE_NUMERIC_ID" ]; then
            ISSUE_NUMERIC_ID=$(echo "$LOOKUP_RESPONSE" | grep -o '"id":[0-9]*' | head -1 | grep -o '[0-9]*' || true)
          fi

          if [ -z "$ISSUE_NUMERIC_ID" ]; then
            echo "âŒ Issue not found: $ISSUE_ID"
            echo "ğŸ’¡ Check at: https://sentry.io/organizations/$SENTRY_ORG/issues/"
            exit 0
          fi

          echo "âœ… Found issue: $ISSUE_ID (numeric ID: $ISSUE_NUMERIC_ID)"

          # Step 2: Resolve using direct issue endpoint
          echo "ğŸ”§ Resolving issue as: $STATUS"
          RESOLVE_URL="https://sentry.io/api/0/issues/$ISSUE_NUMERIC_ID/"
          RESOLVE_DATA='{"status":"'"$STATUS"'"}'

          RESOLVE_RESPONSE=$(sentry_api "$RESOLVE_URL" "PUT" "$RESOLVE_DATA") || true

          if [ "$RESOLVE_RESPONSE" = "NETWORK_ERROR" ]; then
            echo "âŒ Network error resolving issue"
            exit 1
          fi

          if echo "$RESOLVE_RESPONSE" | grep -q '"status"'; then
            echo "âœ… Issue $ISSUE_ID resolved successfully!"
            echo "ğŸ”— View at: https://sentry.io/organizations/$SENTRY_ORG/issues/$ISSUE_NUMERIC_ID/"
          else
            echo "âš ï¸  Response: $(echo "$RESOLVE_RESPONSE" | head -c 500)"
          fi

  auto-resolve-on-deploy:
    if: github.event_name == 'push'
    runs-on: ubuntu-latest
    timeout-minutes: 3
    continue-on-error: true

    permissions:
      contents: read

    steps:
      - name: Auto-Resolve Old Issues
        env:
          SENTRY_AUTH_TOKEN: ${{ secrets.SENTRY_AUTH_TOKEN }}
          SENTRY_ORG: ${{ secrets.SENTRY_ORG || 'twodragon' }}
          SENTRY_PROJECT: ${{ secrets.SENTRY_PROJECT || 'tech-blog' }}
        run: |
          # â”€â”€â”€ Reusable curl-retry function â”€â”€â”€
          sentry_api() {
            local url="$1"
            local method="${2:-GET}"
            local data="${3:-}"
            local max_retries=3
            local retry=0
            local http_code=""
            local body=""
            local response=""

            while [ $retry -lt $max_retries ]; do
              if [ -n "$data" ]; then
                response=$(curl -s --max-time 15 -w "\n%{http_code}" \
                  -X "$method" \
                  -H "Authorization: Bearer $SENTRY_AUTH_TOKEN" \
                  -H "Content-Type: application/json" \
                  -d "$data" \
                  "$url" 2>&1)
              else
                response=$(curl -s --max-time 15 -w "\n%{http_code}" \
                  -X "$method" \
                  -H "Authorization: Bearer $SENTRY_AUTH_TOKEN" \
                  -H "Content-Type: application/json" \
                  "$url" 2>&1)
              fi
              local exit_code=$?

              http_code=$(echo "$response" | tail -n1)
              body=$(echo "$response" | sed '$d')

              if [ "$exit_code" -eq 0 ] && echo "$http_code" | grep -qE '^[0-9]{3}$'; then
                echo "$body"
                return 0
              fi

              retry=$((retry + 1))
              if [ $retry -lt $max_retries ]; then
                echo "âš ï¸  Retry $retry/$max_retries (curl exit: $exit_code)..." >&2
                sleep $((retry + 1))
              fi
            done

            echo "NETWORK_ERROR"
            return 0
          }

          echo "ğŸš€ Auto-resolving unresolved issues on deploy..."

          # Token í™•ì¸
          if [ -z "$SENTRY_AUTH_TOKEN" ]; then
            echo "âŒ SENTRY_AUTH_TOKEN not set"
            exit 1
          fi

          # Get unresolved issues
          ISSUES_URL="https://sentry.io/api/0/projects/$SENTRY_ORG/$SENTRY_PROJECT/issues/?query=is:unresolved&sort=date"
          ISSUES_RESPONSE=$(sentry_api "$ISSUES_URL") || true

          if [ "$ISSUES_RESPONSE" = "NETWORK_ERROR" ]; then
            echo "âŒ Network error fetching issues"
            exit 1
          fi

          # Extract issue IDs (limit to 10 to avoid rate limits)
          ISSUE_IDS=$(echo "$ISSUES_RESPONSE" | grep -o '"id":"[0-9]*"' | grep -o '[0-9]*' | head -10 || true)

          if [ -z "$ISSUE_IDS" ]; then
            echo "âœ… No unresolved issues found"
            exit 0
          fi

          ISSUE_COUNT=$(echo "$ISSUE_IDS" | wc -l | tr -d ' ')
          echo "ğŸ” Found $ISSUE_COUNT unresolved issue(s) (max 10)"

          RESOLVED_COUNT=0
          FAILED_COUNT=0

          # Resolve each issue
          for ISSUE_ID in $ISSUE_IDS; do
            echo "ğŸ”§ Resolving issue $ISSUE_ID..."
            RESOLVE_URL="https://sentry.io/api/0/issues/$ISSUE_ID/"
            RESOLVE_DATA='{"status":"resolvedInNextRelease"}'

            RESOLVE_RESPONSE=$(sentry_api "$RESOLVE_URL" "PUT" "$RESOLVE_DATA") || true

            if [ "$RESOLVE_RESPONSE" = "NETWORK_ERROR" ]; then
              echo "âš ï¸  Failed to resolve issue $ISSUE_ID (network error)"
              FAILED_COUNT=$((FAILED_COUNT + 1))
            elif echo "$RESOLVE_RESPONSE" | grep -q '"status":"resolvedInNextRelease"'; then
              echo "âœ… Resolved issue $ISSUE_ID"
              RESOLVED_COUNT=$((RESOLVED_COUNT + 1))
            else
              echo "âš ï¸  Unexpected response for issue $ISSUE_ID"
              FAILED_COUNT=$((FAILED_COUNT + 1))
            fi

            # Small delay to respect rate limits
            sleep 0.5
          done

          echo ""
          echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
          echo "ğŸ“Š Auto-Resolve Summary"
          echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
          echo "âœ… Resolved: $RESOLVED_COUNT"
          echo "âš ï¸  Failed: $FAILED_COUNT"
          echo "ğŸ“ Total processed: $ISSUE_COUNT"
          echo "ğŸ”— View issues: https://sentry.io/organizations/$SENTRY_ORG/issues/"
          echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"

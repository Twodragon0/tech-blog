개선일: 2026-01-11 23:44:55
원본 포스트: 2025-06-06-클라우드_시큐리티_과정_7기_-_8주차_CICD와_Kubernetes_보안_실전_가이드.md
개선 후 대본 길이: 6785자
Remotion 구간 수: 38개
예상 총 길이: 1342.6초 (22.4분, 1.5배속 기준 14.9분)

============================================================
개선된 강의용 대본
============================================================

(강의 시작 배경음악이 서서히 줄어들며)

여러분, 안녕하세요. IT/DevSecOps 전문 강사 OOO입니다.

혹시 최근 클라우드 환경에서 발생한 대규모 서비스 해킹 소식, 들어보셨나요? 공격자들은 더 이상 완성된 서비스의 정문만 두드리지 않습니다. 대부분의 공격은 개발 초기 단계나 배포 과정, 즉 우리의 CI/CD 파이프라인과 Kubernetes 클러스터의 아주 작은 취약점을 파고듭니다.

이렇게 하루가 다르게 변화하고 복잡해지는 클라우드 환경에서, 우리 DevSecOps 엔지니어들은 보안과 개발 효율성이라는 두 마리 토끼를 잡기 위해 끊임없이 고민할 수밖에 없습니다. 개발은 더 빨라져야 하는데, 보안은 더 튼튼해야 한다는 딜레마에 빠지게 되죠.

그래서 오늘, 이 고민을 해결해 드릴 실질적인 가이드를 준비했습니다. GitHub Actions 보안 설정부터 시작해서, Kubernetes의 핵심 보안 기능인 RBAC, Pod Security Standards, 그리고 Network Policy의 올바른 구현 방법까지. 더 나아가 Kyverno, Falco, Cosign 같은 강력한 오픈소스 도구를 활용한 이미지 및 런타임 보안 전략까지, 현대 GitOps 환경에서 DevSecOps를 완성하는 모든 것을 총망라해 드리겠습니다.

이 강의가 끝날 때쯤, 여러분은 개발 초기 단계인 '코드 커밋'부터 애플리케이션이 실행되는 '런타임'까지, 클라우드 네이티브 애플리케이션의 전 생명주기에 걸쳐 보안을 완벽하게 책임지는 실질적인 노하우를 갖추게 되실 겁니다.

자, 그럼 클라우드 보안 전문가의 길을 향한 여정, 함께 시작해볼까요?

가장 먼저 살펴볼 부분은 바로 CI/CD 파이프라인 보안의 기초입니다. 왜 CI/CD 보안이 그토록 중요할까요? 파이프라인은 우리 코드와 인프라를 연결하는 ‘중앙 고속도로’와 같습니다. 코드를 빌드하고, 테스트하고, 배포하는 모든 과정의 핵심이죠. 만약 이 고속도로가 해커에게 장악당한다면, 그 위를 지나는 모든 데이터와 애플리케이션, 즉 우리 시스템 전체가 위험에 처하게 됩니다.

바로 이곳이 개발 초기 단계부터 보안을 적용하는 'Shift-Left Security', 즉 보안을 왼쪽으로 이동시킨다는 개념의 최전선이라고 할 수 있습니다. 문제가 발생한 뒤에 고치는 것이 아니라, 애초에 문제가 생기지 않도록 파이프라인 단계에서부터 방어벽을 치는 것이죠.

가장 대중적인 도구인 GitHub Actions를 예로 들어보겠습니다. 여러분의 CI/CD 파이프라인이 GitHub Actions를 사용한다면, 가장 먼저 ‘permissions’ 설정을 최소화해야 합니다. 예를 들어, 단순히 코드를 읽어와 빌드만 하는 잡(job)에 코드 저장소에 대한 쓰기 권한을 주는 것은, 은행 창구 직원에게 금고 마스터키를 주는 것과 같습니다. 빌드 과정에서 쓰기 권한이 필요 없다면, 명시적으로 읽기 전용으로 설정하는 것이 보안의 기본 중의 기본입니다.

또한, API 키나 데이터베이스 비밀번호 같은 민감 정보, 즉 Secret 관리는 아무리 강조해도 지나치지 않습니다. 이런 정보를 코드에 그대로 하드코딩하는 것은 정말 위험한 일입니다. GitHub에 공개된 수많은 코드에서 이런 Secret이 유출되어 막대한 피해가 발생하곤 합니다. 반드시 GitHub Secrets나 HashiCorp Vault와 같은 전용 Secret 관리 도구를 사용해 암호화된 상태로 안전하게 관리하고, 필요한 파이프라인 단계에서만 주입해서 사용해야 합니다.

그리고 이제는 선택이 아닌 필수, 바로 파이프라인에 각종 보안 테스트 도구를 완벽하게 통합하는 것입니다.
첫째, SAST, 즉 정적 애플리케이션 보안 테스트입니다. Semgrep이나 SonarQube 같은 도구를 사용하면, 코드가 실행되기 전, 소스코드 자체를 분석해서 SQL 인젝션이나 크로스사이트 스크립팅 같은 잠재적 취약점을 미리 찾아낼 수 있습니다. 코드의 보안 문법 검사기라고 생각하시면 쉽습니다.

둘째, 실수로 커밋된 민감 정보를 찾아내는 Secret 스캐닝입니다. Gitleaks나 TruffleHog 같은 도구를 활용하면, 개발자가 실수로 코드에 포함시킨 API 키나 비밀번호를 커밋 단계에서부터 탐지하고 차단하여 유출을 원천적으로 막을 수 있습니다.

셋째, SCA, 즉 오픈소스 의존성 취약점 스캔입니다. 요즘 우리는 수많은 오픈소스 라이브러리를 가져다 쓰죠. Trivy 같은 도구는 여러분이 사용하는 라이브러리와 그 하위 의존성까지 모두 분석해서, 이미 알려진 보안 취약점(CVE)이 있는지 꼼꼼하게 확인해줍니다.

마지막으로 DAST, 동적 애플리케이션 보안 테스트입니다. OWASP ZAP과 같은 도구는 빌드가 완료되고 실제로 동작하는 애플리케이션을 대상으로 외부 공격자의 관점에서 취약점을 테스트합니다. 이 모든 것을 CI/CD 파이프라인에 자동화하면, 보안 결함을 초기에, 그리고 자동으로 발견하고 수정할 수 있는 강력한 시스템이 완성됩니다.

자, 이제 파이프라인을 통과한 안전한 아티팩트가 배포될 환경, Kubernetes 클러스터의 보안으로 넘어가 보겠습니다.
두 번째 주제는 Kubernetes RBAC, 즉 역할 기반 접근 제어입니다. Kubernetes 환경에서 ‘누가, 무엇을, 어디까지 할 수 있는가’를 정의하는 RBAC는 최소 권한 원칙을 적용하는 가장 핵심적인 요소입니다. RBAC는 크게 Role과 ClusterRole, 그리고 이를 사용자나 그룹에 연결하는 RoleBinding과 ClusterRoleBinding으로 구성됩니다.

Role은 특정 네임스페이스 안에서만 유효한 권한을 정의하고, ClusterRole은 클러스터 전체에 걸친 광범위한 권한을 정의하죠. 예를 들어, 개발팀에게는 자신들의 ‘dev’ 네임스페이스에서 Pod를 생성하고 로그를 볼 수 있는 한정된 Role을 부여하고, 클러스터 전체를 관리해야 하는 운영팀에게는 노드나 스토리지 같은 클러스터 전체 리소스를 관리할 수 있는 강력한 ClusterRole을 부여하는 식입니다. 절대로 편의를 위해 모든 사용자에게 ‘cluster-admin’ 권한을 부여해서는 안 됩니다.

Pod가 Kubernetes API 서버와 통신할 때 사용하는 계정인 ServiceAccount 역시 매우 중요합니다. 이 ServiceAccount에도 정말 필요한 최소한의 권한만 부여해야 합니다. 만약 Pod가 API 서버와 통신할 필요가 없다면, `automountServiceAccountToken: false` 설정을 통해 불필요한 토큰 마운트를 원천적으로 차단하는 것이 좋은 보안 습관입니다.

세 번째는 Pod Security Standards, 줄여서 PSS입니다. PSS는 Pod가 가질 수 있는 보안 속성의 집합을 미리 정의해 놓은 Kubernetes의 기본 내장 보안 기능입니다. Privileged, Baseline, Restricted라는 세 가지 프로파일이 있는데, 이름에서 알 수 있듯이 Privileged는 가장 허용적이고, Restricted는 가장 엄격합니다.

특별한 이유가 없다면, 일반적으로 Restricted 프로파일을 기본으로 적용하여 가장 엄격한 보안을 유지하는 것이 좋습니다. 네임스페이스 레벨에서 PSS를 강제하면, 해당 네임스페이스에 배포되는 모든 Pod에 일관된 보안 정책을 자동으로 적용할 수 있습니다. 예를 들어, Pod의 `securityContext`를 통해 컨테이너가 root 권한으로 실행되지 않도록 `runAsNonRoot: true`를 설정하거나, 컨테이너 파일 시스템을 읽기 전용으로 만들어 악성코드가 파일을 쓰는 것을 방지하는 `readOnlyRootFilesystem: true`를 사용하는 것이 대표적인 모범 사례입니다. 또한, `allowPrivilegeEscalation: false` 설정은 컨테이너 내부에서 권한 상승 공격을 방지하는 데 매우 효과적입니다.

네 번째는 Network Policy 구현입니다. Kubernetes 클러스터 내부의 Pod 간 통신을 제어하는 Network Policy는 마이크로서비스 환경에서 네트워크 격리를 위한 핵심 도구입니다. 기본적으로 Kubernetes는 모든 Pod가 서로 자유롭게 통신할 수 있도록 설정되어 있습니다. 이는 공격자가 하나의 Pod를 장악했을 때, 다른 Pod로 쉽게 이동하며 피해를 확산시키는 ‘측면 이동(Lateral Movement)’ 공격에 매우 취약합니다.

가장 안전한 접근 방식은, 먼저 모든 트래픽을 차단하는 `default-deny` 정책을 적용하고, 그 후에 꼭 필요한 트래픽만 명시적으로 허용하는 화이트리스트 방식을 사용하는 것입니다. 예를 들어, 웹 서비스 Pod는 데이터베이스 Pod의 3306번 포트로만 통신할 수 있도록 제한하고, 그 외의 다른 모든 Pod로부터 들어오는 인바운드 트래픽은 차단하는 것이죠. 이를 통해 공격의 확산 범위를 크게 줄일 수 있습니다.

다섯 번째 주제는 Secret 관리의 심화 과정입니다. Kubernetes의 Secret 오브젝트는 민감 정보를 저장하는 데 사용되지만, 기본적으로는 데이터를 Base64로 인코딩만 할 뿐, 암호화해서 저장하지는 않습니다. 즉, 누구나 쉽게 디코딩해서 원본 내용을 볼 수 있다는 뜻이죠.

따라서 더 안전한 Secret 관리가 반드시 필요합니다. External Secrets Operator는 AWS Secrets Manager, Azure Key Vault, GCP Secret Manager 같은 외부의 전문 Secret 관리 시스템과 Kubernetes Secret을 안전하게 동기화하여 관리 부담을 줄이고 보안을 대폭 강화해줍니다.

특히 GitOps 환경에서는 Sealed Secrets가 매우 유용합니다. 민감 정보를 개발자의 로컬 환경에서 암호화하여 Git 저장소에 안전하게 저장하고, 오직 여러분의 Kubernetes 클러스터에 설치된 컨트롤러만이 이 Secret을 복호화하여 사용할 수 있게 해주죠. 물론, HashiCorp Vault와 같은 강력한 중앙 집중식 Secret 관리 솔루션을 연동하는 것도 매우 강력한 선택지입니다.

여섯 번째는 컨테이너 이미지 보안입니다. 우리가 사용하는 컨테이너 이미지가 정말 안전한지, 변조되지는 않았는지 검증하는 것은 매우 중요합니다. 여기서 등장하는 것이 바로 Admission Controller입니다. Admission Controller는 Pod가 클러스터에 배포되기 직전, 최종 검문소 역할을 하며 우리가 설정한 특정 정책을 만족하는지 검사합니다.

Kyverno와 같은 정책 엔진을 활용하면, 이러한 정책을 코드로 쉽게 관리할 수 있습니다. 예를 들어, 암호화 서명이 없는 이미지는 배포를 차단하거나, 신뢰할 수 있는 특정 레지스트리에서 온 이미지만 허용하는 정책을 YAML 파일로 간단하게 구현할 수 있습니다. 특히, Cosign으로 서명된 이미지만 클러스터에 배포되도록 강제하면, 이미지의 출처와 무결성을 완벽하게 보장할 수 있습니다. 또한, Trivy 같은 취약점 스캐너와 연동하여 알려진 심각한 취약점이 있는 이미지는 아예 배포되지 않도록 사전에 차단하는 정책을 설정하는 것도 가능합니다.

일곱 번째는 런타임 보안입니다. 모든 방어선을 뚫고 배포된 Pod가 실행 중일 때 발생하는 의심스러운 활동을 탐지하는 것은 우리 보안의 마지막 방어선입니다. Falco는 시스템 호출, 즉 커널 레벨에서 발생하는 모든 행위를 감시하여 비정상적인 활동을 탐지하는 대표적인 런타임 보안 도구입니다.

예를 들어, 웹 서버 컨테이너 내에서 갑자기 셸이 실행되거나, 민감한 시스템 파일에 접근하려는 시도, 혹은 예상치 못한 외부 네트워크로 연결을 시도하는 등의 행위를 실시간으로 감지하고 즉시 경고를 발생시킬 수 있습니다. Falco가 제공하는 풍부한 기본 규칙 세트를 활용하거나, 우리 환경에 맞춰 사용자 정의 규칙을 추가하여 보안 가시성을 극대화할 수 있습니다.

마지막으로, 2025년을 향한 Kubernetes 보안 업데이트의 주요 내용을 간략하게 짚어보겠습니다. Kubernetes는 2024년 말 1.32 버전부터 2025년 1.35 버전까지 보안 기능을 대폭 강화했습니다.

첫째, Kubelet API에 대한 접근 제어가 더욱 세밀해졌습니다. 과거에는 다소 포괄적이었던 Kubelet API 권한을 이제는 노드별, Pod별로 아주 정교하게 제어할 수 있게 되었습니다. 이는 측면 이동 공격을 방지하고 침해 사고 발생 시 피해 범위를 최소화하는 데 큰 도움이 됩니다.

둘째, 포렌식을 위한 Credential 추적 기능이 강화되었습니다. 어떤 사용자가 어떤 Credential을 사용했는지 추적하기가 훨씬 쉬워져, 침해 사고 발생 시 원인 분석 및 대응 속도를 획기적으로 높일 수 있습니다.

셋째, 리눅스 커널 6.3 이상에서 User Namespaces가 정식 지원됩니다. 이는 워크로드 격리를 크게 강화하는 기능으로, 만약 공격자가 컨테이너를 탈출하더라도 호스트의 root 권한을 획득하는 것이 거의 불가능해집니다. /proc, /sys 같은 민감한 시스템 정보 접근 또한 격리되어 보안 효과가 극대화됩니다.

오늘 우리는 CI/CD 파이프라인 보안부터 Kubernetes 클러스터의 각종 보안 설정, 그리고 이미지와 런타임 보안에 이르기까지 DevSecOps의 핵심 전략을 모두 살펴보았습니다. 기억하십시오. DevSecOps는 단순히 도구를 도입하는 것이 아니라, 개발, 보안, 운영이 함께 책임지는 문화이자 프로세스입니다.

오늘 배운 이 전략들을 여러분의 환경에 하나씩 적용해 나가신다면, 여러분은 더 이상 보안 위협에 흔들리지 않는 견고하고 안정적인 클라우드 네이티브 환경을 구축할 수 있을 것입니다. 여러분은 단순한 개발자나 운영자가 아닌, 여러분의 서비스를 지키는 진정한 보안 전문가로 거듭나게 될 것입니다.

경청해주셔서 감사합니다.

============================================================
Remotion 동기화 구간 정보
============================================================

[구간 1] 시작: 0.00초, 길이: 4.40초
(강의 시작 배경음악이 서서히 줄어들며)

[구간 2] 시작: 4.40초, 길이: 7.60초
여러분, 안녕하세요. IT/DevSecOps 전문 강사 OOO입니다.

[구간 3] 시작: 12.00초, 길이: 31.40초
혹시 최근 클라우드 환경에서 발생한 대규모 서비스 해킹 소식, 들어보셨나요? 공격자들은 더 이상 완성된 서비스의 정문만 두드리지 않습니다. 대부분의 공격은 개발 초기 단계나 배포 ...

[구간 4] 시작: 43.40초, 길이: 29.00초
이렇게 하루가 다르게 변화하고 복잡해지는 클라우드 환경에서, 우리 DevSecOps 엔지니어들은 보안과 개발 효율성이라는 두 마리 토끼를 잡기 위해 끊임없이 고민할 수밖에 없습니다...

[구간 5] 시작: 72.40초, 길이: 54.00초
그래서 오늘, 이 고민을 해결해 드릴 실질적인 가이드를 준비했습니다. GitHub Actions 보안 설정부터 시작해서, Kubernetes의 핵심 보안 기능인 RBAC, Pod ...

[구간 6] 시작: 126.40초, 길이: 24.80초
이 강의가 끝날 때쯤, 여러분은 개발 초기 단계인 '코드 커밋'부터 애플리케이션이 실행되는 '런타임'까지, 클라우드 네이티브 애플리케이션의 전 생명주기에 걸쳐 보안을 완벽하게 책임...

[구간 7] 시작: 151.20초, 길이: 7.80초
자, 그럼 클라우드 보안 전문가의 길을 향한 여정, 함께 시작해볼까요?

[구간 8] 시작: 159.00초, 길이: 42.60초
가장 먼저 살펴볼 부분은 바로 CI/CD 파이프라인 보안의 기초입니다. 왜 CI/CD 보안이 그토록 중요할까요? 파이프라인은 우리 코드와 인프라를 연결하는 ‘중앙 고속도로’와 같습...

[구간 9] 시작: 201.60초, 길이: 30.60초
바로 이곳이 개발 초기 단계부터 보안을 적용하는 'Shift-Left Security', 즉 보안을 왼쪽으로 이동시킨다는 개념의 최전선이라고 할 수 있습니다. 문제가 발생한 뒤에 ...

[구간 10] 시작: 232.20초, 길이: 53.60초
가장 대중적인 도구인 GitHub Actions를 예로 들어보겠습니다. 여러분의 CI/CD 파이프라인이 GitHub Actions를 사용한다면, 가장 먼저 ‘permissions’...

[구간 11] 시작: 285.80초, 길이: 54.00초
또한, API 키나 데이터베이스 비밀번호 같은 민감 정보, 즉 Secret 관리는 아무리 강조해도 지나치지 않습니다. 이런 정보를 코드에 그대로 하드코딩하는 것은 정말 위험한 일입...

[구간 12] 시작: 339.80초, 길이: 11.60초
그리고 이제는 선택이 아닌 필수, 바로 파이프라인에 각종 보안 테스트 도구를 완벽하게 통합하는 것입니다.

[구간 13] 시작: 351.40초, 길이: 33.60초
첫째, SAST, 즉 정적 애플리케이션 보안 테스트입니다. Semgrep이나 SonarQube 같은 도구를 사용하면, 코드가 실행되기 전, 소스코드 자체를 분석해서 SQL 인젝션이...

[구간 14] 시작: 385.00초, 길이: 28.80초
둘째, 실수로 커밋된 민감 정보를 찾아내는 Secret 스캐닝입니다. Gitleaks나 TruffleHog 같은 도구를 활용하면, 개발자가 실수로 코드에 포함시킨 API 키나 비밀...

[구간 15] 시작: 413.80초, 길이: 29.60초
셋째, SCA, 즉 오픈소스 의존성 취약점 스캔입니다. 요즘 우리는 수많은 오픈소스 라이브러리를 가져다 쓰죠. Trivy 같은 도구는 여러분이 사용하는 라이브러리와 그 하위 의존성...

[구간 16] 시작: 443.40초, 길이: 37.20초
마지막으로 DAST, 동적 애플리케이션 보안 테스트입니다. OWASP ZAP과 같은 도구는 빌드가 완료되고 실제로 동작하는 애플리케이션을 대상으로 외부 공격자의 관점에서 취약점을 ...

[구간 17] 시작: 480.60초, 길이: 13.40초
자, 이제 파이프라인을 통과한 안전한 아티팩트가 배포될 환경, Kubernetes 클러스터의 보안으로 넘어가 보겠습니다.

[구간 18] 시작: 494.00초, 길이: 43.00초
두 번째 주제는 Kubernetes RBAC, 즉 역할 기반 접근 제어입니다. Kubernetes 환경에서 ‘누가, 무엇을, 어디까지 할 수 있는가’를 정의하는 RBAC는 최소 권...

[구간 19] 시작: 537.00초, 길이: 56.80초
Role은 특정 네임스페이스 안에서만 유효한 권한을 정의하고, ClusterRole은 클러스터 전체에 걸친 광범위한 권한을 정의하죠. 예를 들어, 개발팀에게는 자신들의 ‘dev’ ...

[구간 20] 시작: 593.80초, 길이: 45.00초
Pod가 Kubernetes API 서버와 통신할 때 사용하는 계정인 ServiceAccount 역시 매우 중요합니다. 이 ServiceAccount에도 정말 필요한 최소한의 권한...

[구간 21] 시작: 638.80초, 길이: 43.20초
세 번째는 Pod Security Standards, 줄여서 PSS입니다. PSS는 Pod가 가질 수 있는 보안 속성의 집합을 미리 정의해 놓은 Kubernetes의 기본 내장 보...

[구간 22] 시작: 682.00초, 길이: 82.80초
특별한 이유가 없다면, 일반적으로 Restricted 프로파일을 기본으로 적용하여 가장 엄격한 보안을 유지하는 것이 좋습니다. 네임스페이스 레벨에서 PSS를 강제하면, 해당 네임스...

[구간 23] 시작: 764.80초, 길이: 51.80초
네 번째는 Network Policy 구현입니다. Kubernetes 클러스터 내부의 Pod 간 통신을 제어하는 Network Policy는 마이크로서비스 환경에서 네트워크 격리를...

[구간 24] 시작: 816.60초, 길이: 47.00초
가장 안전한 접근 방식은, 먼저 모든 트래픽을 차단하는 `default-deny` 정책을 적용하고, 그 후에 꼭 필요한 트래픽만 명시적으로 허용하는 화이트리스트 방식을 사용하는 것...

[구간 25] 시작: 863.60초, 길이: 32.00초
다섯 번째 주제는 Secret 관리의 심화 과정입니다. Kubernetes의 Secret 오브젝트는 민감 정보를 저장하는 데 사용되지만, 기본적으로는 데이터를 Base64로 인코딩...

[구간 26] 시작: 895.60초, 길이: 39.20초
따라서 더 안전한 Secret 관리가 반드시 필요합니다. External Secrets Operator는 AWS Secrets Manager, Azure Key Vault, GCP...

[구간 27] 시작: 934.80초, 길이: 45.20초
특히 GitOps 환경에서는 Sealed Secrets가 매우 유용합니다. 민감 정보를 개발자의 로컬 환경에서 암호화하여 Git 저장소에 안전하게 저장하고, 오직 여러분의 Kube...

[구간 28] 시작: 980.00초, 길이: 40.60초
여섯 번째는 컨테이너 이미지 보안입니다. 우리가 사용하는 컨테이너 이미지가 정말 안전한지, 변조되지는 않았는지 검증하는 것은 매우 중요합니다. 여기서 등장하는 것이 바로 Admis...

[구간 29] 시작: 1020.60초, 길이: 61.20초
Kyverno와 같은 정책 엔진을 활용하면, 이러한 정책을 코드로 쉽게 관리할 수 있습니다. 예를 들어, 암호화 서명이 없는 이미지는 배포를 차단하거나, 신뢰할 수 있는 특정 레지...

[구간 30] 시작: 1081.80초, 길이: 32.60초
일곱 번째는 런타임 보안입니다. 모든 방어선을 뚫고 배포된 Pod가 실행 중일 때 발생하는 의심스러운 활동을 탐지하는 것은 우리 보안의 마지막 방어선입니다. Falco는 시스템 호...

[구간 31] 시작: 1114.40초, 길이: 40.40초
예를 들어, 웹 서버 컨테이너 내에서 갑자기 셸이 실행되거나, 민감한 시스템 파일에 접근하려는 시도, 혹은 예상치 못한 외부 네트워크로 연결을 시도하는 등의 행위를 실시간으로 감지...

[구간 32] 시작: 1154.80초, 길이: 24.20초
마지막으로, 2025년을 향한 Kubernetes 보안 업데이트의 주요 내용을 간략하게 짚어보겠습니다. Kubernetes는 2024년 말 1.32 버전부터 2025년 1.35 버...

[구간 33] 시작: 1179.00초, 길이: 32.60초
첫째, Kubelet API에 대한 접근 제어가 더욱 세밀해졌습니다. 과거에는 다소 포괄적이었던 Kubelet API 권한을 이제는 노드별, Pod별로 아주 정교하게 제어할 수 있...

[구간 34] 시작: 1211.60초, 길이: 24.80초
둘째, 포렌식을 위한 Credential 추적 기능이 강화되었습니다. 어떤 사용자가 어떤 Credential을 사용했는지 추적하기가 훨씬 쉬워져, 침해 사고 발생 시 원인 분석 및...

[구간 35] 시작: 1236.40초, 길이: 35.80초
셋째, 리눅스 커널 6.3 이상에서 User Namespaces가 정식 지원됩니다. 이는 워크로드 격리를 크게 강화하는 기능으로, 만약 공격자가 컨테이너를 탈출하더라도 호스트의 r...

[구간 36] 시작: 1272.20초, 길이: 35.40초
오늘 우리는 CI/CD 파이프라인 보안부터 Kubernetes 클러스터의 각종 보안 설정, 그리고 이미지와 런타임 보안에 이르기까지 DevSecOps의 핵심 전략을 모두 살펴보았습...

[구간 37] 시작: 1307.60초, 길이: 32.40초
오늘 배운 이 전략들을 여러분의 환경에 하나씩 적용해 나가신다면, 여러분은 더 이상 보안 위협에 흔들리지 않는 견고하고 안정적인 클라우드 네이티브 환경을 구축할 수 있을 것입니다....

[구간 38] 시작: 1340.00초, 길이: 2.60초
경청해주셔서 감사합니다.


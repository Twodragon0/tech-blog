{
  "script": "안녕하세요, 여러분. 오늘은 클라우드 보안 과정 6주차 내용을 5분 동안 핵심만 요약해 드리겠습니다. 오늘의 주제는 크게 두 가지입니다. 첫째는 **AWS WAF와 CloudFront를 활용한 엣지 보안 아키텍처**, 둘째는 **GitHub을 통한 DevSecOps 실전 적용**입니다.\n자, 먼저 AWS 보안 아키텍처부터 볼까요?\n여러분이 S3에 정적 웹사이트를 호스팅한다고 생각해보세요. 이때 S3 버킷에 직접 접근할 수 있게 두면 큰 보안 위험이 됩니다. 그래서 **CloudFront(CDN)**를 앞에 두고, S3로 가는 직접 경로를 막는 거죠.\n이때 사용하는 것이 **OAC(Origin Access Control)**입니다. OAC를 설정하면 오직 CloudFront를 통해서만 S3 콘텐츠에 안전하게 접근할 수 있습니다. 꼭 기억하세요.\nS3 버킷 정책에서 직접 접근을 반드시 차단해야 이 설정이 의미가 있습니다.\n그리고 CloudFront 앞단에 **AWS WAF**를 배치하면 훨씬 강력해집니다. WAF로 할 수 있는 일은 크게 세 가지예요.\n1.  **Geo-blocking**: 특정 국가에서 오는 트래픽을 아예 차단할 수 있습니다. 물론 VPN으로 우회 가능하니 유일한 수단으로 생각하면 안 되고요.\n2.  **헤더 조작**: 요청(Request) 헤더를 검사해 비정상적인 접근을 차단하거나, 응답(Response) 헤더에서 불필요한 서버 정보를 지우고 보안 헤더(HSTS, CSP 등)를 넣을 수 있습니다.\n3.  **공격 차단**: SQL Injection, XSS 같은 일반적인 웹 공격을 AWS가 제공하는 관리형 규칙으로 쉽게 막을 수 있죠.\n이제 두 번째 주제, **GitHub DevSecOps**로 넘어갈게요.\n'Shift Left', 즉 개발 초기 단계부터 보안을 적용하는 게 핵심입니다. GitHub에서는 이걸 도와주는 훌륭한 도구들이 있어요.\n*   **Dependabot**: 여러분이 사용하는 라이브러리(의존성)에 취약점이 발견되면, 자동으로 패치된 버전으로 업데이트하는 PR을 만들어줍니다. 설정 파일 하나면 끝이에요.\n*   **CodeQL**: 코드를 정적 분석해서 보안 취약점을 찾아냅니다. SQLi, XSS, SSRF 같은 문제를 코드가 저장소에 푸시될 때마다 자동으로 검사하도록 GitHub Actions에 통합할 수 있습니다.\n*   **Secret Scanning**: 실수로 API 키나 비밀번호가 코드에 커밋되는 걸 방지합니다. 푸시 자체를 막는 Push Protection 기능이 특히 강력하죠.\n이런 도구들을 **GitHub Actions** 워크플로우에 조합하면, 코드 품질 검사, 보안 스캔, 빌드, 배포까지 모두 자동화된 안전한 파이프라인을 만들 수 있습니다.\n마지막으로, 오늘 강의의 백미인 **실전 케이스 스터디**를 공유드리겠습니다.\n제가 개인 기술 블로그(Jekyll)를 유지보수하면서, 포스팅을 자동화하는 Python 스크립트에 **CodeQL을 돌려봤더니 고위험 취약점이 6건이나 나왔습니다.** 그중 하나가 **SSRF**였어요.\n외부에서 입력받은 URL을 제대로 검증하지 않고 요청을 보내고 있었던 거죠. 해결 방법은 `urllib.parse`로 URL을 분석하고, 허용된 도메인 목록(Allow-list)과만 통신하도록 수정한 것입니다.\n또 다른 문제는 **민감 정보(API 키)가 로그에 평문으로 노출**되는 거였는데, 이를 해결하기 위해 데이터 마스킹 함수를 구현했습니다.\n여기서 중요한 교훈은, **DevSecOps는 거창한 시스템이 아니라 사소한 코드 한 줄부터 보안을 고려하는 습관에서 시작된다**는 점입니다.\n정리해 드리면, 오늘은 **1) AWS WAF/CloudFront로 엣지 보안을 구축하는 방법**, **2) GitHub 도구들로 개발 생명주기 전반에 보안을 내재화하는 방법**, **3) 실제 코드를 보안 관점으로 점검하고 수정하는 실전 감각**을 배웠습니다.\n다음 시간에는 컨테이너 보안을 다룰 예정이니, 미리 Docker와 Kubernetes 기본 개념을 살펴보시면 좋겠습니다. 여러분도 지금 당장 개인 프로젝트 저장소에 CodeQL 스캔을 한번 적용해 보는 걸 추천드립니다. 이상으로 강의를 마치겠습니다. 감사합니다.",
  "segments": [
    {
      "index": 0,
      "text": "안녕하세요, 여러분. 오늘은 클라우드 보안 과정 6주차 내용을 5분 동안 핵심만 요약해 드리겠습니다. 오늘의 주제는 크게 두 가지입니다. 첫째는 **AWS WAF와 CloudFront를 활용한 엣지 보안 아키텍처**, 둘째는 **GitHub을 통한 DevSecOps 실전 적용**입니다.",
      "duration": 5.714285714285714,
      "startTime": 0
    },
    {
      "index": 1,
      "text": "자, 먼저 AWS 보안 아키텍처부터 볼까요?",
      "duration": 0.8571428571428571,
      "startTime": 5.714285714285714
    },
    {
      "index": 2,
      "text": "여러분이 S3에 정적 웹사이트를 호스팅한다고 생각해보세요. 이때 S3 버킷에 직접 접근할 수 있게 두면 큰 보안 위험이 됩니다. 그래서 **CloudFront(CDN)**를 앞에 두고, S3로 가는 직접 경로를 막는 거죠.",
      "duration": 4.428571428571429,
      "startTime": 6.571428571428571
    },
    {
      "index": 3,
      "text": "이때 사용하는 것이 **OAC(Origin Access Control)**입니다. OAC를 설정하면 오직 CloudFront를 통해서만 S3 콘텐츠에 안전하게 접근할 수 있습니다. 꼭 기억하세요.",
      "duration": 3.892857142857143,
      "startTime": 11.0
    },
    {
      "index": 4,
      "text": "S3 버킷 정책에서 직접 접근을 반드시 차단해야 이 설정이 의미가 있습니다. 그리고 CloudFront 앞단에 **AWS WAF**를 배치하면 훨씬 강력해집니다. WAF로 할 수 있는 일은 크게 세 가지예요.",
      "duration": 4.107142857142858,
      "startTime": 14.892857142857142
    },
    {
      "index": 5,
      "text": "1.  **Geo-blocking**: 특정 국가에서 오는 트래픽을 아예 차단할 수 있습니다. 물론 VPN으로 우회 가능하니 유일한 수단으로 생각하면 안 되고요.",
      "duration": 3.2142857142857144,
      "startTime": 19.0
    },
    {
      "index": 6,
      "text": "2.  **헤더 조작**: 요청(Request) 헤더를 검사해 비정상적인 접근을 차단하거나, 응답(Response) 헤더에서 불필요한 서버 정보를 지우고 보안 헤더(HSTS, CSP 등)를 넣을 수 있습니다.",
      "duration": 4.142857142857143,
      "startTime": 22.214285714285715
    },
    {
      "index": 7,
      "text": "3.  **공격 차단**: SQL Injection, XSS 같은 일반적인 웹 공격을 AWS가 제공하는 관리형 규칙으로 쉽게 막을 수 있죠. 이제 두 번째 주제, **GitHub DevSecOps**로 넘어갈게요.",
      "duration": 4.214285714285714,
      "startTime": 26.357142857142858
    },
    {
      "index": 8,
      "text": "'Shift Left', 즉 개발 초기 단계부터 보안을 적용하는 게 핵심입니다. GitHub에서는 이걸 도와주는 훌륭한 도구들이 있어요.",
      "duration": 2.7142857142857144,
      "startTime": 30.571428571428573
    },
    {
      "index": 9,
      "text": "*   **Dependabot**: 여러분이 사용하는 라이브러리(의존성)에 취약점이 발견되면, 자동으로 패치된 버전으로 업데이트하는 PR을 만들어줍니다. 설정 파일 하나면 끝이에요.",
      "duration": 3.607142857142857,
      "startTime": 33.285714285714285
    },
    {
      "index": 10,
      "text": "*   **CodeQL**: 코드를 정적 분석해서 보안 취약점을 찾아냅니다. SQLi, XSS, SSRF 같은 문제를 코드가 저장소에 푸시될 때마다 자동으로 검사하도록 GitHub Actions에 통합할 수 있습니다.",
      "duration": 4.321428571428571,
      "startTime": 36.89285714285714
    },
    {
      "index": 11,
      "text": "*   **Secret Scanning**: 실수로 API 키나 비밀번호가 코드에 커밋되는 걸 방지합니다. 푸시 자체를 막는 Push Protection 기능이 특히 강력하죠.",
      "duration": 3.5,
      "startTime": 41.21428571428571
    },
    {
      "index": 12,
      "text": "이런 도구들을 **GitHub Actions** 워크플로우에 조합하면, 코드 품질 검사, 보안 스캔, 빌드, 배포까지 모두 자동화된 안전한 파이프라인을 만들 수 있습니다. 마지막으로, 오늘 강의의 백미인 **실전 케이스 스터디**를 공유드리겠습니다.",
      "duration": 4.928571428571429,
      "startTime": 44.71428571428571
    },
    {
      "index": 13,
      "text": "제가 개인 기술 블로그(Jekyll)를 유지보수하면서, 포스팅을 자동화하는 Python 스크립트에 **CodeQL을 돌려봤더니 고위험 취약점이 6건이나 나왔습니다.** 그중 하나가 **SSRF**였어요.",
      "duration": 4.035714285714286,
      "startTime": 49.64285714285714
    },
    {
      "index": 14,
      "text": "외부에서 입력받은 URL을 제대로 검증하지 않고 요청을 보내고 있었던 거죠. 해결 방법은 `urllib.parse`로 URL을 분석하고, 허용된 도메인 목록(Allow-list)과만 통신하도록 수정한 것입니다.",
      "duration": 4.178571428571429,
      "startTime": 53.67857142857142
    },
    {
      "index": 15,
      "text": "또 다른 문제는 **민감 정보(API 키)가 로그에 평문으로 노출**되는 거였는데, 이를 해결하기 위해 데이터 마스킹 함수를 구현했습니다.",
      "duration": 2.75,
      "startTime": 57.857142857142854
    },
    {
      "index": 16,
      "text": "여기서 중요한 교훈은, **DevSecOps는 거창한 시스템이 아니라 사소한 코드 한 줄부터 보안을 고려하는 습관에서 시작된다**는 점입니다.",
      "duration": 2.8214285714285716,
      "startTime": 60.607142857142854
    },
    {
      "index": 17,
      "text": "정리해 드리면, 오늘은 **1) AWS WAF/CloudFront로 엣지 보안을 구축하는 방법**, **2) GitHub 도구들로 개발 생명주기 전반에 보안을 내재화하는 방법**, **3) 실제 코드를 보안 관점으로 점검하고 수정하는 실전 감각**을 배웠습니다.",
      "duration": 5.214285714285714,
      "startTime": 63.42857142857142
    },
    {
      "index": 18,
      "text": "다음 시간에는 컨테이너 보안을 다룰 예정이니, 미리 Docker와 Kubernetes 기본 개념을 살펴보시면 좋겠습니다. 여러분도 지금 당장 개인 프로젝트 저장소에 CodeQL 스캔을 한번 적용해 보는 걸 추천드립니다. 이상으로 강의를 마치겠습니다. 감사합니다.",
      "duration": 5.214285714285714,
      "startTime": 68.64285714285714
    }
  ],
  "metadata": {
    "생성일": "2026-01-11 19:10:27",
    "대본 길이": "2098자",
    "원본 포스트": "2026-01-08-클라우드_보안_과정_8기_6주차_AWS_WAF_CloudFront_보안_아키텍처_및_GitHub_DevSecOps_실전.md",
    "사용된 API": "Gemini API Key → DeepSeek API",
    "API 전략": "Gemini 우선"
  },
  "totalDuration": 73.85714285714285
}